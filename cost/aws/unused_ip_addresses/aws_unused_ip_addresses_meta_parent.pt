name "AWS Unused IP Addresses Meta Parent"
rs_pt_ver 20180301
type "policy"
short_description "Applies and manages \"child\" [AWS Unused IP Addresses](https://github.com/flexera/policy_templates/tree/master/cost/aws/unused_ip_addresses/) Policies."
severity "low"
category "Cost"
tenancy "single"
default_frequency "15 minutes"
info(
  version: "0.1"
)

##############################################################################
# Parameters
##############################################################################

## Meta Parent Parameters
## These are params specific to the meta parent policy.
parameter "param_dimension_filter_includes" do
  type "list"
  label "Dimension Include Filters"
  description <<-EOS
  Filters [`dimension_name=dimension_value` pairs] to determine which AWS Accounts returned by the Flexera Bill Analysis API to **INCLUDE** and be applied to.
  During each run this policy will select AWS Accounts who match **all** the filters defined and apply a child policy for each.
  If no include filters are provided, then all AWS Accounts are included by default.
  Most of the dimensions in Flexera can be used [default dimensions, custom tag dimensions, rule-based dimensions].  Full list of available dimensions documented in the [Bill Analysis API Docs](https://reference.rightscale.com/bill_analysis/).
  EOS
end

parameter "param_dimension_filter_excludes" do
  type "list"
  label "Dimension Exclude Filters"
  description <<-EOS
  Filters [`dimension_name=dimension_value` pairs] to determine which AWS Accounts returned by  the Flexera Bill Analysis API to **EXCLUDE** and *not* have policy applied to.
  During each run this policy will select AWS Accounts who match **all** the filters defined here and excludes them from results.
  Can be used to exclude specific AWS Accounts [`vendor_account=123456789012`]
  Most of the dimensions in Flexera can be used [default dimensions, custom tag dimensions, rule-based dimensions].  Full list of available dimensions documented in the [Bill Analysis API Docs](https://reference.rightscale.com/bill_analysis/).
  EOS
end

parameter "param_policy_schedule" do
  type "string"
  label "Child Policy Schedule"
  description "The interval at which the child policy checks for conditions and generates incidents."
  default "daily"
  allowed_values "daily", "weekly", "monthly"
end

## Child Policy Parameters
## These are params from the child policy, excluding param_email and param_aws_account_number
parameter "param_allowed_regions" do
  type "list"
  label "Allowed Regions"
  allowed_pattern /^([a-zA-Z-_]+-[a-zA-Z0-9-_]+-[0-9-_]+,*|)+$/
  description "A list of allowed regions. See the README for more details"
end

parameter "param_exclude_tags" do
  type "list"
  label "Exclusion Tags"
  description "A list of AWS tags to ignore Elastic IPs. Format: Key=Value"
end

# parameter "param_email" do
#   type "list"
#   label "Email addresses"
#   description "Email addresses of the recipients you wish to notify when new incidents are created"
# end

# parameter "param_aws_account_number" do
#   type "string"
#   label "Account Number"
#   description "The account number for AWS STS Cross Account Roles."
#   default ""
# end

parameter "param_automatic_action" do
  type "list"
  label "Automatic Actions"
  description "When this value is set, this policy will automatically take the selected action(s)"
  allowed_values ["Delete Unused IPs"]
end

parameter "param_log_to_cm_audit_entries" do
  type "string"
  label "Log to CM Audit Entries"
  description "Boolean for whether or not to log any debugging information from actions to CM Audit Entries, this should be left set to No on Flexera EU"
  default "No"
  allowed_values "Yes", "No"
end

###############################################################################
# Authentication
###############################################################################

credentials "auth_aws" do
  schemes "aws","aws_sts"
  label "AWS"
  description "Select the AWS Cloud Credential from the list."
  tags "provider=aws"
  aws_account_number $param_aws_account_number
end

auth "auth_rs", type: "rightscale"

###############################################################################
# Datasources
###############################################################################

# Get Applied Parent Policy Details
datasource "ds_self_policy_information" do
  request do
    auth $auth_rs
    host rs_governance_host
    path join(["/api/governance/projects/", rs_project_id, "/applied_policies/", policy_id])
    header "Api-Version", "1.0"
  end
  result do
    encoding "json"
    field "name", jmes_path(response, "name")
    field "creator_id", jmes_path(response, "created_by.id")
    field "credentials", jmes_path(response, "credentials")
    field "options", jmes_path(response, "options")
  end
end

datasource "ds_format_self" do
  run_script $js_format_self, $ds_self_policy_information
end

script "js_format_self", type: "javascript" do
  parameters "unformatted"
  result "formatted"
  code <<-EOS
  formatted={
    "name": unformatted["name"],
    "creator_id": unformatted["creator_id"],
    "credentials": unformatted["credentials"],
    "options": {
      // param_email should always be an empty list
      "param_email": [],
      // All other child policy params excluding param_aws_account_number
      "param_allowed_regions": [],
      "param_exclude_tags": [],
      "param_automatic_action": [],
      "param_log_to_cm_audit_entries": "No"
    }
  }
  for (x=0;x<unformatted.options.length; x++) {
    if (formatted["options"][unformatted.options[x]["name"]] != undefined) {
      formatted["options"][unformatted.options[x]["name"]] = unformatted.options[x]["value"]
    }
  }
  EOS
end

# Get Child Policy Details
datasource "ds_child_policy_information" do
  request do
    auth $auth_rs
    host rs_governance_host
    path "/api/governance/projects/113453/policy_templates/6297b4fd1f946c0001e88e39"
    header "Api-Version", "1.0"
  end
  result do
    encoding "json"
    field "name", jmes_path(response, "name")
    field "href", jmes_path(response, "href")
    field "short_description", jmes_path(response, "short_description")
  end
end

# policy_created_by_id
# Get the Billing Center IDs the customer has access to
datasource "ds_get_billing_centers" do
  request do
    auth $auth_rs
    host rs_optima_host
    path join(["/analytics/users/", val($ds_format_self, "creator_id"), "/orgs/", rs_org_id, "/billing_centers"])
    header "Api-Version", "0.1"
  end
end

script "js_make_billing_center_request", type: "javascript" do
  parameters "rs_org_id", "rs_optima_host", "billing_centers_unformatted", "param_dimension_filter_includes", "param_dimension_filter_excludes"
  result "request"
  code <<-EOS

  billing_centers_formatted = []

  for (x=0; x< billing_centers_unformatted.length; x++) {
    billing_centers_formatted.push(billing_centers_unformatted[x]["id"])
  }

  finish = new Date()
  finishFormatted = finish.toJSON().split("T")[0]
  start = new Date()
  start.setDate(start.getDate() - 30)
  startFormatted = start.toJSON().split("T")[0]

  // Default dimensions and filter expressions required for meta parent policy
  var dimensions = ["vendor_account", "vendor_account_name"];
  var filter_expressions = [
    { dimension: "vendor", type: "equal", value: "AWS" }
  ]

  // Append to default dimensions and filter expressions using parent policy params
  _.each(param_dimension_filter_includes, function (v) {
    // split key=value string
    var split = v.split("=");
    var k = split[0];
    var v = split[1];
    // append to lists
    dimensions.push(k);
    filter_expressions.push({ dimension: k, type: "equal", value: v });
  });

  // Append to filter expressions using exclude policy params
  _.each(param_dimension_filter_excludes, function (v) {
    // split key=value string
    var split = v.split("=");
    var k = split[0];
    var v = split[1];
    // append to lists
    dimensions.push(k);
    filter_expressions.push({ "type": "not", "expression": { "dimension": k, "type": "equal", "value": v } });
  });

  // Produces a duplicate-free version of the array
  dimensions = _.uniq(dimensions);

  var body = {
    "dimensions": dimensions,
    "granularity":"day",
    "start_at": startFormatted,
    "end_at": finishFormatted,
    "metrics":["cost_amortized_unblended_adj"],
    "billing_center_ids": billing_centers_formatted,
    "filter":
    {
      "type": "and",
      "expressions": filter_expressions
    },
    "summarized": true
  }
  var request = {
    auth:  'auth_rs',
    host:  rs_optima_host,
    scheme: 'https',
    verb: 'POST',
    path:  "/bill-analysis/orgs/"+ rs_org_id + "/costs/aggregated",
    headers: {
      "API-Version": "1.0",
      "Content-Type":"application/json"
    },
    body: JSON.stringify(body)
  }
  EOS
end

# Get the AWS acounts
datasource "ds_get_aws_accounts" do
  request do
    run_script $js_make_billing_center_request, rs_org_id, rs_optima_host, $ds_get_billing_centers, $param_dimension_filter_includes, $param_dimension_filter_excludes
  end
  result do
    encoding "json"
    collect jmes_path(response,"rows[*]") do
      field "aws_account_id", jmes_path(col_item,"dimensions.vendor_account")
      field "aws_account_name", jmes_path(col_item,"dimensions.vendor_account_name")
    end
  end
end

# Get Child policies
datasource "ds_get_existing_policies" do
  request do
    auth $auth_rs
    host rs_governance_host
    path join(["/api/governance/projects/", rs_project_id, "/applied_policies"])
    header "Api-Version", "1.0"
    query "meta_parent_policy_id", policy_id
  end
  result do
    collect jq(response, '.items[]?') do
      field "name", jq(col_item, ".name")
      field "applied_policy_id", jq(col_item, ".id")
      field "options", jq(col_item, ".options")
      field "updated_at", jq(col_item, ".updated_at")
      field "status", jq(col_item, ".status")
    end
  end
end

# Get Child policies incidents
datasource "ds_get_existing_policies_incidents" do
  request do
    auth $auth_rs
    host rs_governance_host
    path join(["/api/governance/projects/", rs_project_id, "/incidents"])
    header "Api-Version", "1.0"
    query "meta_parent_policy_id", policy_id
  end
  result do
    collect jq(response, '.items[]?') do
      field "incident_id", jq(col_item, ".id")
      field "applied_policy_id", jq(col_item, ".applied_policy.id")
      field "state", jq(col_item, ".state")
      field "violation_data_count", jq(col_item, ".violation_data_count")
      field "updated_at", jq(col_item, ".updated_at")
    end
  end
end

datasource "ds_format_incidents" do
  run_script $js_format_existing_policies_incidents, $ds_get_existing_policies_incidents
end

script "js_format_existing_policies_incidents", type: "javascript" do
  parameters "unformatted"
  result "formatted"
  code <<-EOS
  formatted={}
  for (x=0;x<unformatted.length; x++) {
    current = unformatted[x]
    formatted[current.applied_policy_id] = {incident_id: current.incident_id, state: current.state, violation_data_count: current.violation_data_count, updated_at: current.updated_at}
  }
  EOS
end

datasource "ds_format_existing_policies" do
  run_script $js_format_existing_policies, $ds_get_existing_policies, $ds_format_incidents
end

# format
# duplicates logic should compare updated at
# we can validate update here when destructring the existing policy options, don't need updated at
# format options
script "js_format_existing_policies", type: "javascript" do
  parameters "unformatted", "incidents"
  result "result"
  code <<-EOS

  result = {}
  formatted = {}
  duplicates = []
  tracking = {}

  for (x=0; x<unformatted.length; x++) {
    options= {
      // param_email should always be an empty list
      "param_email": [],
      // param_aws_account_number should default to empty string
      "param_aws_account_number": "",
      // All other child policy params excluding param_aws_account_number and param_email
      "param_allowed_regions": [],
      "param_exclude_tags": [],
      "param_automatic_action": [],
      "param_log_to_cm_audit_entries": "No"
    }
    for (y=0;y<unformatted[x].options.length; y++) {
      if (options[unformatted[x].options[y]["name"]] != undefined) {
        options[unformatted[x].options[y]["name"]] = unformatted[x].options[y]["value"]
      }
    }
    aws_account_id=options["param_aws_account_number"]
    if (formatted[aws_account_id] == undefined) {
      formatted[aws_account_id] = {
        "applied_policy_id":unformatted[x]["applied_policy_id"],
        "applied_policy_name":unformatted[x]["name"],
        "status":unformatted[x]["status"],
        "updated_at":unformatted[x]["updated_at"],
        "incident": incidents[unformatted[x]["applied_policy_id"]],
        "options": options
      }
      tracking[aws_account_id] = false
    } else {
      current = formatted[aws_account_id]

      currDate = new Date(current.updated_at)
      newDate = new Date(unformatted[x].updated_at)

      if (currDate > newDate) {
        duplicates.push({
          "applied_policy_id":unformatted[x]["applied_policy_id"],
          "applied_policy_name":unformatted[x]["name"],
          "status":unformatted[x]["status"],
          "updated_at":unformatted[x]["updated_at"],
          "incident": incidents[unformatted[x]["applied_policy_id"]]
        })
      } else {
        duplicates.push({
          "applied_policy_id":current["applied_policy_id"],
          "applied_policy_name":current["applied_policy_name"],
          "status":current["status"],
          "updated_at":current["updated_at"],
          "incident": current["incident"]
        })
        formatted[aws_account_id] = {
          "applied_policy_id":unformatted[x]["applied_policy_id"],
          "applied_policy_name":unformatted[x]["name"],
          "status":unformatted[x]["status"],
          "updated_at":unformatted[x]["updated_at"],
          "incident": incidents[unformatted[x]["applied_policy_id"]],
          "options": options
        }

      }
    }
  }

  result.formatted=formatted
  result.duplicates=duplicates
  result.tracking=tracking
  EOS
end

datasource "ds_take_in_parameters" do
  run_script $js_take_in_parameters, $ds_get_aws_accounts, $ds_format_self, $ds_child_policy_information, $ds_format_existing_policies, policy_id, f1_app_host, rs_org_id, rs_project_id, $param_policy_schedule
end

# hardcode template href with id from catalog
# catalog policies show in customer's published templates with their org id
# "template_href": "/api/governance/orgs/" + rs_org_id + "/published_templates/62618616e3dff80001572bf0"
# update logic: the only reason we're going to update the child policies for is changes to options
# and only some options, email is always blank and aws_account_id is tied to the idenity of each policy, so: new account creation, removal of account: termination
# param_automatic_action is a list with only one action, unless the person is applying using an API and putting the same value multiple times this should either be a length of 0 or 1
# param_log_to_cm_audit_entries is a String of Yes or No
# param_exclude_tags and param_allowed_regions are arrays. I'm doing an update on the order changing but the values remaining the same.
# If we only want to do an update on the values changing we could sort before doing the equality check.
script "js_take_in_parameters", type: "javascript" do
  parameters "aws_account_ids", "parent_policy", "child_policy", "existing_policies", "meta_parent_policy_id", "f1_app_host", "rs_org_id", "rs_project_id", "param_policy_schedule"
  result "grid_and_cwf"
  code <<-EOS

  max_actions = 50

  grid_and_cwf={grid:[], to_create:[], to_update:[], to_delete:[]}

  should_keep = existing_policies.tracking

  project_url_prefix = "https://" + f1_app_host + "/orgs/" + rs_org_id + "/policy/projects/" + rs_project_id

  function add_to_grid(ep, action) {
    policy_status={
      "policy_name": ep["applied_policy_name"],
      "policy_link":project_url_prefix + "/applied-policies/" + ep["applied_policy_id"],
      "meta_policy_status": action,
      "policy_status": ep["status"],
      "policy_last_update": ep["updated_at"],
    }
    if (ep.incident != null) {
      policy_status["incident_link"] = project_url_prefix + "/incidents/" + ep.incident.incident_id
      policy_status["incident_state"] = ep.incident.state
      policy_status["incident_violation_data_count"] = ep.incident.violation_data_count
      policy_status["incident_last_update"] = ep.incident.updated_at
    }
    grid_and_cwf.grid.push(policy_status)
  }

  for (x=0; x<existing_policies.duplicates.length; x++) {
    if (grid_and_cwf.to_delete.length < max_actions) {
      grid_and_cwf.to_delete.push({"id":existing_policies.duplicates[x]["applied_policy_id"], "name": existing_policies.duplicates[x]["applied_policy_name"]})
      add_to_grid(existing_policies.duplicates[x], "terminating")
    } else {
      add_to_grid(existing_policies.duplicates[x], "to be terminated")
    }
  }

  for (x=0; x<aws_account_ids.length; x++) {
    cur = aws_account_ids[x]
    if (existing_policies.formatted[cur.aws_account_id] == undefined) {
      name = child_policy.name + ": " + cur.aws_account_name + " (" + cur.aws_account_id + ") (child policy)"
      description = child_policy.name + " policy applied by [" + parent_policy.name + "](" + project_url_prefix + "/applied-policies/" + meta_parent_policy_id + ") to AWS Account **" + cur.aws_account_name +"** (`" + cur.aws_account_id + "`).  " + child_policy.short_description
      options = [
        // param_email should always be an empty list
        {
          "name": "param_email",
          "value": []
        },
        // param_aws_account_number should be set to current account id
        {
          "name": "param_aws_account_number",
          "value": cur.aws_account_id
        },
        // All other child policy params excluding param_aws_account_number and param_email
        {
          "name": "param_allowed_regions",
          "value": parent_policy.options.param_allowed_regions
        },
        {
          "name": "param_exclude_tags",
          "value": parent_policy.options.param_exclude_tags
        },
        {
          "name": "param_automatic_action",
          "value": parent_policy.options.param_automatic_action
        },
        {
          "name": "param_log_to_cm_audit_entries",
          "value": parent_policy.options.param_log_to_cm_audit_entries
        }
      ]
      if (grid_and_cwf.to_create.length < max_actions) {
        grid_and_cwf.to_create.push({
          "name" : name,
          "description" : description,
          "credentials" : parent_policy.credentials,
          "options" : options,
          "frequency" : param_policy_schedule,
          "meta_parent_policy_id": meta_parent_policy_id,
          "template_href": child_policy.href
        })
        policy_status={
          "policy_name": name,
          "meta_policy_status": "creating policy",
          "policy_status": "",
          "policy_last_update": "",
        }
        grid_and_cwf.grid.push(policy_status)
      } else {
        policy_status={
          "policy_name": name,
          "meta_policy_status": "policy to be created",
          "policy_status": "",
          "policy_last_update": "",
        }
        grid_and_cwf.grid.push(policy_status)
      }
    } else {
      should_keep[cur.aws_account_id]= true
      should_update = false
      options = [
        // param_email should always be an empty list
        {
          "name": "param_email",
          "value": []
        },
        // param_aws_account_number should be set to current account id
        {
          "name": "param_aws_account_number",
          "value": cur.aws_account_id
        },
        // All other child policy params excluding param_aws_account_number and param_email
        {
          "name": "param_allowed_regions",
          "value": parent_policy.options.param_allowed_regions
        },
        {
          "name": "param_exclude_tags",
          "value": parent_policy.options.param_exclude_tags
        },
        {
          "name": "param_automatic_action",
          "value": parent_policy.options.param_automatic_action
        },
        {
          "name": "param_log_to_cm_audit_entries",
          "value": parent_policy.options.param_log_to_cm_audit_entries
        }
      ]

      if (!_.isEqual(parent_policy.options.param_allowed_regions, existing_policies["formatted"][cur.aws_account_id]["options"]["param_allowed_regions"])) {
        should_update = true
      }

      if (!_.isEqual(parent_policy.options.param_exclude_tags, existing_policies["formatted"][cur.aws_account_id]["options"]["param_exclude_tags"])) {
        should_update = true
      }

      if (!_.isEqual(parent_policy.options.param_automatic_action, existing_policies["formatted"][cur.aws_account_id]["options"]["param_automatic_action"])) {
        should_update = true
      }

      if (!_.isEqual(parent_policy.options.param_log_to_cm_audit_entries, existing_policies["formatted"][cur.aws_account_id]["options"]["param_log_to_cm_audit_entries"])) {
        should_update = true
      }

      if (should_update) {
        if (grid_and_cwf.to_update.length < max_actions) {
          add_to_grid(existing_policies.formatted[cur.aws_account_id], "updating")
          name = existing_policies.formatted[cur.aws_account_id].applied_policy_name
          grid_and_cwf.to_update.push({
            "applied_policy_id": existing_policies.formatted[cur.aws_account_id].applied_policy_id,
            "name" : name,
            "description" : description,
            "credentials" : parent_policy.credentials,
            "options" : options,
            "frequency" : param_policy_schedule,
          })
        } else {
          add_to_grid(existing_policies.formatted[cur.aws_account_id], "to be updated")
        }
      } else {
        add_to_grid(existing_policies.formatted[cur.aws_account_id], "running")
      }
    }
  }

  for (key in should_keep) {
    if (!should_keep[key]) {
      if (grid_and_cwf.to_delete.length < max_actions) {
        grid_and_cwf.to_delete.push({"id":existing_policies.formatted[key].applied_policy_id, "name": existing_policies.formatted[key].applied_policy_name})
        add_to_grid(existing_policies.formatted[key], "terminating")
      } else {
        add_to_grid(existing_policies.formatted[key], "to be terminated")
      }
    }
  }

  EOS
end

datasource "ds_only_grid" do
  run_script $js_only_grid, $ds_take_in_parameters
end

script "js_only_grid", type: "javascript" do
  parameters "results"
  result "only_grid"
  code <<-EOS
    only_grid = results.grid
  EOS
end

datasource "ds_to_create" do
  run_script $js_only_create, $ds_take_in_parameters
end

script "js_only_create", type: "javascript" do
  parameters "results"
  result "only_create"
  code <<-EOS
    only_create = results.to_create
  EOS
end

datasource "ds_to_update" do
  run_script $js_only_update, $ds_take_in_parameters
end

script "js_only_update", type: "javascript" do
  parameters "results"
  result "only_update"
  code <<-EOS
    only_update = results.to_update
  EOS
end

datasource "ds_to_delete" do
  run_script $js_only_delete, $ds_take_in_parameters
end

script "js_only_delete", type: "javascript" do
  parameters "results"
  result "only_delete"
  code <<-EOS
    only_delete = results.to_delete
  EOS
end


# Summary and a conditional incident which will show up if any policy is being applied, updated or deleted.
# Minimum of 1 incident, max of four
# Could swap the summary to only showing running
# Could also just have one incident and use meta_status to determine which esclation happens
policy "policy_scheduled_report" do
  validate $ds_only_grid do
    summary_template "Status of Meta Child Policies"
    detail_template <<-EOS
The current status of this Policy's Meta Child Policies:

Total Child Applied Policies: {{ len data }}

| Applied Policy | Meta Child Policy Status | Policy Status | Policy Last Update | Incident | Incident State | Violation Count | Incident Last Update |
| -------------- | ------------------------ | ------------- | ------------------ | -------- | -------------- | --------------- | -------------------- |
{{ range data -}}
| {{- if .policy_link }} [{{ .policy_name }}]({{ .policy_link }}) {{ else }} {{ .policy_name }} {{- end }} | {{- if .meta_policy_status }} {{ .meta_policy_status }} {{ else }} No value {{- end }} | {{- if .policy_status }} {{ .policy_status }} {{ else }} No value {{- end }} | {{- if .policy_last_update }} {{ .policy_last_update }} {{ else }} No value {{- end }} | {{- if .incident_link }} [Incident]({{ .incident_link }}) {{ else }} No Incident {{- end }} | {{- if .incident_state }} {{ .incident_state }} {{ else }} No Incident {{- end }} | {{- if .incident_last_update }} {{ .incident_violation_data_count }} {{ else }} No Incident {{- end }} | {{- if .incident_last_update }} {{ .incident_last_update }} {{ else }} No Incident {{- end }} |
{{ end -}}

EOS
    check false
    # Export Table disabled for now until UI can support URL / linking
    # Without linking the `policy_link`, `incident_link` values are not usable directly from UI
    # export "policy_scheduled_report" do
    #   resource_level true
    #   field "id" do
    #     label "Applied Policy ID"
    #   end
    #   field "policy_name" do
    #     label "Applied Policy Name"
    #   end
    #   field "policy_link" do
    #     label "Applied Policy Link"
    #   end
    #   field "meta_policy_status" do
    #     label "Meta Child Policy Status"
    #   end
    #   field "policy_status" do
    #     label "Policy Status"
    #   end
    #   field "policy_last_update" do
    #     label "Policy Last Update"
    #   end
    #   field "incident_link" do
    #     label "Incident Link"
    #   end
    #   field "incident_state" do
    #     label "Incident State"
    #   end
    #   field "incident_violation_data_count" do
    #     label "Incident Violation Count"
    #   end
    #   field "incident_last_update" do
    #     label "Incident Last Update"
    #   end
    # end
  end
  validate $ds_to_create do
    summary_template "Policies being created"
    detail_template <<-EOS
    Policies Being Created:

    | Appplied Policy |
    | --------------- |
    {{ range data -}}
    | {{ .name }} |
    {{ end -}}
    EOS
    escalate $create_policies
    check eq(size(data),0)
  end
  validate $ds_to_update do
    summary_template "Policies being updated"
    detail_template <<-EOS
    Policies Being Updated:

    | Appplied Policy |
    | --------------- |
    {{ range data -}}
    | {{ .name }} |
    {{ end -}}
    EOS
    escalate $update_policies
    check eq(size(data),0)
  end
  validate $ds_to_delete do
    summary_template "Policies being deleted"
    detail_template <<-EOS
    Policies being Deleted:

    | Appplied Policy |
    | --------------- |
    {{ range data -}}
    | {{ .name }} |
    {{ end -}}
    EOS
    escalate $delete_policies
    check eq(size(data),0)
  end
end

escalation "create_policies" do
  run "create_applied_policies", data, rs_governance_host, rs_project_id
end

# if name !=null
define create_applied_policies($data, $governance_host, $rs_project_id) return $responses do
  $responses = []
  $$debug = []
  foreach $item in $data do
    task_label("Creating Applied Policy with Options: " + to_json($item["options"]))
    $response = http_request(
      verb: "post",
      https: true,
      host: $governance_host,
      href: join(["/api/governance/projects/", $rs_project_id, "/applied_policies"]),
      headers: { "Api-Version": "1.0" },
      body: {
        "name": $item["name"],
        "description": $item["description"],
        "template_href": $item["template_href"],
        "frequency": $item["frequency"],
        "options": $item["options"],
        "credentials": $item["credentials"],
        "meta_parent_policy_id": $item["meta_parent_policy_id"]
      }
    )
    $responses << $response
    $$debug << to_json({
      "response": $response,
      "item": $item,
      "governance_host": $governance_host
    })
  end
end

escalation "update_policies" do
  run "update_applied_policies", data, rs_governance_host, rs_project_id
end

define update_applied_policies($data, $governance_host, $rs_project_id) return $responses do
  $responses = []
  $$debug = []
  foreach $item in $data do
    task_label("Updating Applied Policy with Options: " + to_json($item["options"]))
    $response = http_request(
      verb: "patch",
      https: true,
      host: $governance_host,
      href: join(["/api/governance/projects/", $rs_project_id, "/applied_policies/", $item["applied_policy_id"]]),
      headers: { "Api-Version": "1.0" },
      body: {
        "options": $item["options"]
      }
    )
    $responses << $response
    $$debug << to_json({
      "response": $response,
      "item": $item,
      "governance_host": $governance_host
    })
  end
end


escalation "delete_policies" do
  run "delete_applied_policies", data, rs_governance_host, rs_project_id
end

define delete_applied_policies($data, $governance_host, $rs_project_id) return $responses do
  $responses = []
  $$debug = []
  foreach $item in $data do
    task_label("Deleting Applied Policy: " + $item["id"])
    $response = http_request(
      verb: "delete",
      https: true,
      host: $governance_host,
      href: join(["/api/governance/projects/", $rs_project_id, "/applied_policies/", $item["id"]]),
      headers: { "Api-Version": "1.0" }
    )
    $responses << $response
    $$debug << to_json({
      "response": $response,
      "item": $item,
      "governance_host": $governance_host
    })
  end
end
