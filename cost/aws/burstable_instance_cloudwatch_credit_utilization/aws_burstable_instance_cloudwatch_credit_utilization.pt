name "AWS Burstable Instance CloudWatch Utilization"
rs_pt_ver 20180301
type "policy"
short_description "Gathers AWS CloudWatch CPU and Burst Credit data for instances on 30 day intervals. See the [README](https://github.com/flexera-public/policy_templates/tree/master/cost/aws/burstable_instance_cloudwatch_credit_utilization/) and [docs.flexera.com/flexera/EN/Automation](https://docs.flexera.com/flexera/EN/Automation/AutomationGS.htm) to learn more."
long_description ""
severity "low"
category "Cost"
default_frequency "weekly"
info(
  version: "4.0",
  provider: "AWS",
  service: "Compute",
  policy_set: ""
)

###############################################################################
# Parameters
###############################################################################

parameter "param_email" do
  type "list"
  category "Policy Settings"
  label "Email addresses to notify"
  description "Email addresses of the recipients you wish to notify when new incidents are created"
  default []
end

parameter "param_aws_account_number" do
  type "string"
  category "Policy Settings"
  label "Account Number"
  description "Leave blank; this is for automated use with Meta Policies. See README for more details."
  default ""
end

parameter "param_exclusion_tags" do
  type "list"
  category "Filters"
  label "Exclusion Tags (Key:Value)"
  description "Cloud native tags to ignore resources that you don't want to produce recommendations for. Use Key:Value format for specific tag key/value pairs, and Key:* format to match any resource with a particular key, regardless of value. Examples: env:production, DO_NOT_DELETE:*"
  allowed_pattern /(^$)|[\w]*\:.*/
  default []
end

parameter "param_regions_allow_or_deny" do
  type "string"
  category "Filters"
  label "Allow/Deny Regions"
  description "Allow or Deny entered regions. See the README for more details"
  allowed_values "Allow", "Deny"
  default "Allow"
end

parameter "param_regions_list" do
  type "list"
  category "Filters"
  label "Allow/Deny Regions List"
  allowed_pattern /^([a-zA-Z-_]+-[a-zA-Z0-9-_]+-[0-9-_]+,*|)+$/
  description "A list of allowed or denied regions. See the README for more details"
  default []
end

parameter "param_cpu_surplus_credits" do
  type "number"
  category "Policy Settings"
  label "CPU Surplus Credits"
  description "Number of CPU Surplus Credits to report on. Set to -1 to ignore CPU burst credits"
  default -1
  min_value -1
end

parameter "param_cpu_burst_credit_balance" do
  type "string"
  category "Policy Settings"
  label "Check Burst Credit Balance"
  description "Whether to check burst credit balance against max_earnable_credits"
  default "false"
  allowed_values "true", "false"
end

parameter "param_cooldown_days" do
  type "number"
  category "Policy Settings"
  label "Cooldown Days"
  description "Days to cooldown between checks of same instance"
  default 30
  min_value 1
end

parameter "param_automatic_action" do
  type "list"
  category "Actions"
  label "Automatic Actions"
  description "When this value is set, this policy will automatically take the selected action(s)"
  allowed_values ["Resize Instances"]
  default []
end

###############################################################################
# Authentication
###############################################################################

credentials "auth_aws" do
  schemes "aws", "aws_sts"
  label "AWS"
  description "Select the AWS Credential from the list"
  tags "provider=aws"
  aws_account_number $param_aws_account_number
end

credentials "auth_flexera" do
  schemes "oauth2"
  label "Flexera"
  description "Select Flexera One OAuth2 credentials"
  tags "provider=flexera"
end

###############################################################################
# Pagination
###############################################################################

pagination "pagination_aws" do
  get_page_marker do
    body_path jmes_path(response, "NextToken")
  end
  set_page_marker do
    body_field "NextToken"
  end
end

###############################################################################
# Datasources & Scripts
###############################################################################

datasource "ds_instance_types" do
  request do
    verb "GET"
    host "raw.githubusercontent.com"
    path "/rightscale/policy_templates/master/data/aws/instance_types.json"
    header "User-Agent", "RS Policies"
  end
end

# Get applied policy metadata for use later
datasource "ds_applied_policy" do
  request do
    auth $auth_flexera
    host rs_governance_host
    path join(["/api/governance/projects/", rs_project_id, "/applied_policies/", policy_id])
    header "Api-Version", "1.0"
  end
end

# Get region-specific Flexera API endpoints
datasource "ds_flexera_api_hosts" do
  run_script $js_flexera_api_hosts, rs_optima_host
end

script "js_flexera_api_hosts", type: "javascript" do
  parameters "rs_optima_host"
  result "result"
  code <<-EOS
  host_table = {
    "api.optima.flexeraeng.com": {
      flexera: "api.flexera.com",
      fsm: "api.fsm.flexeraeng.com"
    },
    "api.optima-eu.flexeraeng.com": {
      flexera: "api.flexera.eu",
      fsm: "api.fsm-eu.flexeraeng.com"
    },
    "api.optima-apac.flexeraeng.com": {
      flexera: "api.flexera.au",
      fsm: "api.fsm-apac.flexeraeng.com"
    }
  }

  result = host_table[rs_optima_host]
EOS
end

# Get AWS account info
datasource "ds_cloud_vendor_accounts" do
  request do
    auth $auth_flexera
    host val($ds_flexera_api_hosts, 'flexera')
    path join(["/finops-analytics/v1/orgs/", rs_org_id, "/cloud-vendor-accounts"])
    header "Api-Version", "1.0"
  end
  result do
    encoding "json"
    collect jmes_path(response, "values[*]") do
      field "id", jmes_path(col_item, "aws.accountId")
      field "name", jmes_path(col_item, "name")
      field "tags", jmes_path(col_item, "tags")
    end
  end
end

datasource "ds_get_caller_identity" do
  request do
    auth $auth_aws
    verb "GET"
    host "sts.amazonaws.com"
    path "/"
    header "User-Agent", "RS Policies"
    query "Action", "GetCallerIdentity"
    query "Version", "2011-06-15"
  end
  result do
    encoding "xml"
    collect xpath(response, "//GetCallerIdentityResponse/GetCallerIdentityResult") do
      field "account", xpath(col_item, "Account")
    end
  end
end

datasource "ds_aws_account" do
  run_script $js_aws_account, $ds_cloud_vendor_accounts, $ds_get_caller_identity
end

script "js_aws_account", type:"javascript" do
  parameters "ds_cloud_vendor_accounts", "ds_get_caller_identity"
  result "result"
  code <<-EOS
  result = _.find(ds_cloud_vendor_accounts, function(account) {
    return account['id'] == ds_get_caller_identity[0]['account']
  })

  // This is in case the API does not return the relevant account info
  if (result == undefined) {
    result = {
      id: ds_get_caller_identity[0]['account'],
      name: "",
      tags: {}
    }
  }
EOS
end

datasource "ds_describe_regions" do
  request do
    auth $auth_aws
    verb "GET"
    host "ec2.amazonaws.com"
    path "/"
    query "Action", "DescribeRegions"
    query "Version", "2016-11-15"
    query "Filter.1.Name", "opt-in-status"
    query "Filter.1.Value.1", "opt-in-not-required"
    query "Filter.1.Value.2", "opted-in"
    # Header X-Meta-Flexera has no affect on datasource query, but is required for Meta Policies
    # Forces `ds_is_deleted` datasource to run first during policy execution
    header "Meta-Flexera", val($ds_is_deleted, "path")
  end
  result do
    encoding "xml"
    collect xpath(response, "//DescribeRegionsResponse/regionInfo/item", "array") do
      field "region", xpath(col_item, "regionName")
    end
  end
end

datasource "ds_regions" do
  run_script $js_regions, $ds_describe_regions, $param_regions_list, $param_regions_allow_or_deny
end

script "js_regions", type:"javascript" do
  parameters "ds_describe_regions", "param_regions_list", "param_regions_allow_or_deny"
  result "result"
  code <<-EOS
  allow_deny_test = { "Allow": true, "Deny": false }

  if (param_regions_list.length > 0) {
    result = _.filter(ds_describe_regions, function(item) {
      return _.contains(param_regions_list, item['region']) == allow_deny_test[param_regions_allow_or_deny]
    })
  } else {
    result = ds_describe_regions
  }
EOS
end

datasource "ds_instance_sets" do
  iterate $ds_regions
  request do
    auth $auth_aws
    host join(['ec2.', val(iter_item, 'region'), '.amazonaws.com'])
    path '/'
    header 'User-Agent', 'RS Policies'
    header 'Content-Type', 'text/xml'
    query 'Action', 'DescribeInstances'
    query 'Version', '2016-11-15'
    query 'Filter.1.Name', 'instance-state-name'
    query 'Filter.1.Value.1', 'running'
  end
  result do
    encoding "xml"
    collect xpath(response, "//DescribeInstancesResponse/reservationSet/item", "array") do
      field "instances_set" do
        collect xpath(col_item,"instancesSet/item","array") do
          field "region",val(iter_item, "region")
          field "instanceId", xpath(col_item, "instanceId")
          field "imageId", xpath(col_item, "imageId")
          field "resourceType", xpath(col_item, "instanceType")
          field "platform", xpath(col_item, "platformDetails")
          field "privateDnsName", xpath(col_item, "privateDnsName")
          field "launchTime", xpath(col_item, "launchTime")
          field "tags" do
            collect xpath(col_item,"tagSet/item", "array") do
              field "key", xpath(col_item, "key")
              field "value", xpath(col_item, "value")
            end
          end
        end
      end
    end
  end
end

datasource "ds_instances" do
  run_script $js_instances, $ds_instance_sets, $ds_instance_types, $param_exclusion_tags
end

script "js_instances", type: "javascript" do
  parameters "ds_instance_sets", "ds_instance_types", "param_exclusion_tags"
  result "result"
  code <<-EOS
  result = []

  _.each(ds_instance_sets, function(item) {
    if (param_exclusion_tags.length > 0) {
      filtered_instances = _.reject(item['instances_set'], function(instance) {
        instance_tags = []

        if (instance['tags'] != null && instance['tags'] != undefined) {
          _.each(instance['tags'], function(tag) {
            instance_tags.push([tag['key'], tag['value']].join(':'))
            instance_tags.push([tag['key'], '*'].join(':'))
          })
        }

        exclude_instance = false

        _.each(param_exclusion_tags, function(exclusion_tag) {
          if (_.contains(instance_tags, exclusion_tag)) {
            exclude_instance = true
          }
        })

        return exclude_instance
      })

      result = result.concat(filtered_instances)
    } else {
      result = result.concat(item['instances_set'])
    }
  })

  result = _.map(result, function(instance) {
    resourceTypeInfo = ds_instance_types[instance['resourceType']]

    return {
      region: instance['region'],
      instanceId: instance['instanceId'],
      imageId: instance['imageId'],
      resourceType: instance['resourceType'],
      platform: instance['platform'],
      privateDnsName: instance['privateDnsName'],
      launchTime: instance['launchTime'],
      tags: instance['tags'],
      resourceTypeInfo: resourceTypeInfo
    }
  })
EOS
end

datasource "ds_instances_cpu_usage" do
  iterate $ds_instances
  request do
    run_script $js_get_instance_stats, val(iter_item, "region"), val(iter_item, "instanceId"), "CPUUtilization"
  end
  result do
    encoding "json"
    collect jmes_path(response, "GetMetricStatisticsResponse.GetMetricStatisticsResult.Datapoints[*]") do
      field "cpuUnit", jmes_path(col_item, "Unit")
      field "cpuMaximum", jmes_path(col_item, "Maximum")
      field "cpuMinimum", jmes_path(col_item, "Minimum")
      field "cpuAverage", jmes_path(col_item, "Average")
      field "region", val(iter_item, "region")
      field "instanceId", val(iter_item, "instanceId")
      field "imageId", val(iter_item, "imageId")
      field "resourceType", val(iter_item, "resourceType")
      field "resourceTypeInfo", val(iter_item, "resourceTypeInfo")
      field "platform", val(iter_item, "platform")
      field "privateDnsName", val(iter_item, "privateDnsName")
      field "launchTime", val(iter_item, "launchTime")
      field "tags", val(iter_item, "tags")
    end
  end
end

datasource "ds_instances_cpu_credit_balance" do
  iterate $ds_instances_cpu_usage
  request do
    run_script $js_get_instance_stats, val(iter_item, "region"), val(iter_item, "instanceId"), "CPUCreditBalance"
  end
  result do
    encoding "json"
    collect jmes_path(response, "GetMetricStatisticsResponse.GetMetricStatisticsResult.Datapoints[*]") do
      field "cpuCreditBalanceUnit", jmes_path(col_item, "Unit")
      field "cpuCreditBalanceMaximum", jmes_path(col_item, "Maximum")
      field "cpuCreditBalanceMinimum", jmes_path(col_item, "Minimum")
      field "cpuCreditBalanceAverage", jmes_path(col_item, "Average")
      field "cpuUnit", val(iter_item, "cpuUnit")
      field "cpuMaximum", val(iter_item, "cpuMaximum")
      field "cpuMinimum", val(iter_item, "cpuMinimum")
      field "cpuAverage", val(iter_item, "cpuAverage")
      field "region", val(iter_item, "region")
      field "instanceId", val(iter_item, "instanceId")
      field "imageId", val(iter_item, "imageId")
      field "resourceType", val(iter_item, "resourceType")
      field "resourceTypeInfo", val(iter_item, "resourceTypeInfo")
      field "platform", val(iter_item, "platform")
      field "privateDnsName", val(iter_item, "privateDnsName")
      field "launchTime", val(iter_item, "launchTime")
      field "tags", val(iter_item, "tags")
    end
  end
end

datasource "ds_instances_cpu_credit_surplus" do
  iterate $ds_instances_cpu_credit_balance
  request do
    run_script $js_get_instance_stats, val(iter_item, "region"), val(iter_item, "instanceId"), "CPUSurplusCreditBalance"
  end
  result do
    encoding "json"
    collect jmes_path(response, "GetMetricStatisticsResponse.GetMetricStatisticsResult.Datapoints[*]") do
      field "cpuSurplusCreditBalanceUnit", jmes_path(col_item, "Unit")
      field "cpuSurplusCreditBalanceMaximum", jmes_path(col_item, "Maximum")
      field "cpuSurplusCreditBalanceMinimum", jmes_path(col_item, "Minimum")
      field "cpuSurplusCreditBalanceAverage", jmes_path(col_item, "Average")
      field "cpuCreditBalanceUnit", val(iter_item, "cpuCreditBalanceUnit")
      field "cpuCreditBalanceMaximum", val(iter_item, "cpuCreditBalanceMaximum")
      field "cpuCreditBalanceMinimum", val(iter_item, "cpuCreditBalanceMinimum")
      field "cpuCreditBalanceAverage", val(iter_item, "cpuCreditBalanceAverage")
      field "cpuUnit", val(iter_item, "cpuUnit")
      field "cpuMaximum", val(iter_item, "cpuMaximum")
      field "cpuMinimum", val(iter_item, "cpuMinimum")
      field "cpuAverage", val(iter_item, "cpuAverage")
      field "region", val(iter_item, "region")
      field "instanceId", val(iter_item, "instanceId")
      field "imageId", val(iter_item, "imageId")
      field "resourceType", val(iter_item, "resourceType")
      field "resourceTypeInfo", val(iter_item, "resourceTypeInfo")
      field "platform", val(iter_item, "platform")
      field "privateDnsName", val(iter_item, "privateDnsName")
      field "launchTime", val(iter_item, "launchTime")
      field "tags", val(iter_item, "tags")
    end
  end
end

datasource "ds_instances_with_stats" do
  iterate $ds_instances_cpu_credit_surplus
  request do
    run_script $js_get_instance_stats, val(iter_item, "region"), val(iter_item, "instanceId"), "CPUSurplusCreditsCharged"
  end
  result do
    encoding "json"
    collect jmes_path(response, "GetMetricStatisticsResponse.GetMetricStatisticsResult.Datapoints[*]") do
      field "CPUSurplusCreditsChargedUnit", jmes_path(col_item, "Unit")
      field "CPUSurplusCreditsChargedMaximum", jmes_path(col_item, "Maximum")
      field "CPUSurplusCreditsChargedMinimum", jmes_path(col_item, "Minimum")
      field "CPUSurplusCreditsChargedAverage", jmes_path(col_item, "Average")
      field "cpuSurplusCreditBalanceUnit", val(iter_item, "cpuSurplusCreditBalanceUnit")
      field "cpuSurplusCreditBalanceMaximum", val(iter_item, "cpuSurplusCreditBalanceMaximum")
      field "cpuSurplusCreditBalanceMinimum", val(iter_item, "cpuSurplusCreditBalanceMinimum")
      field "cpuSurplusCreditBalanceAverage", val(iter_item, "cpuSurplusCreditBalanceAverage")
      field "cpuCreditBalanceUnit", val(iter_item, "cpuCreditBalanceUnit")
      field "cpuCreditBalanceMaximum", val(iter_item, "cpuCreditBalanceMaximum")
      field "cpuCreditBalanceMinimum", val(iter_item, "cpuCreditBalanceMinimum")
      field "cpuCreditBalanceAverage", val(iter_item, "cpuCreditBalanceAverage")
      field "cpuUnit", val(iter_item, "cpuUnit")
      field "cpuMaximum", val(iter_item, "cpuMaximum")
      field "cpuMinimum", val(iter_item, "cpuMinimum")
      field "cpuAverage", val(iter_item, "cpuAverage")
      field "region", val(iter_item, "region")
      field "instanceId", val(iter_item, "instanceId")
      field "imageId", val(iter_item, "imageId")
      field "resourceType", val(iter_item, "resourceType")
      field "resourceTypeInfo", val(iter_item, "resourceTypeInfo")
      field "platform", val(iter_item, "platform")
      field "privateDnsName", val(iter_item, "privateDnsName")
      field "launchTime", val(iter_item, "launchTime")
      field "tags", val(iter_item, "tags")
    end
  end
end

script "js_get_instance_stats", type: "javascript" do
  result "request"
  parameters "region", "instanceId", "metricName"
  code <<-EOS
  start_date = new Date(new Date().setDate(new Date().getDate() - 30)).toISOString()
  end_date = new Date().toISOString()

  var request = {
    auth: "auth_aws",
    host: "monitoring." + region + ".amazonaws.com",
    path: "/",
    headers: {
      "User-Agent": "RS Policies",
      "Content-Type": "application/json",
      "x-amz-target": "GraniteServiceVersion20100801.GetMetricStatistics",
      "Accept": "application/json",
      "Content-Encoding": "amz-1.0"
    },
    query_params: {
      "Action": "GetMetricStatistics",
      "Version": "2010-08-01",
      "Namespace": "AWS/EC2",
      "MetricName": metricName,
      "Dimensions.member.1.Name": "InstanceId",
      "Dimensions.member.1.Value": instanceId,
      "StartTime": start_date,
      "EndTime": end_date,
      "Period": "2592000",
      "Statistics.member.1": "Maximum",
      "Statistics.member.2": "Average",
      "Statistics.member.3": "Minimum"
    }
  }
EOS
end

datasource "ds_merged_metrics" do
  run_script $js_merged_metrics, $ds_cloudwatch_cpu_usage, $ds_cloudwatch_cpu_credit_balance, $ds_cloudwatch_cpu_surplus_credit_balance, $ds_cloudwatch_cpu_surplus_credits_charged
end


script "js_merged_metrics", type: "javascript" do
  parameters "ds_cloudwatch_cpu_usage", "ds_cloudwatch_cpu_credit_balance", "ds_cloudwatch_cpu_surplus_credit_balance", "ds_cloudwatch_cpu_surplus_credits_charged"
  result "merged_results"
  code <<-EOS
  var merged_results = []
  for ( i = 0; i < ds_cloudwatch_cpu_usage.length; i++){
    var instance_id = ds_cloudwatch_cpu_usage[i].instanceId
    var cloudwatch_cpu_credit_balance = _.find(ds_cloudwatch_cpu_credit_balance, function(record) { return record.instanceId == instance_id; })
    var cloudwatch_cpu_surplus_credit_balance = _.find(ds_cloudwatch_cpu_surplus_credit_balance, function(record) { return record.instanceId == instance_id; })
    var cloudwatch_cpu_surplus_credits_charged = _.find(ds_cloudwatch_cpu_surplus_credits_charged, function(record) { return record.instanceId == instance_id; })

    if (cloudwatch_cpu_credit_balance != null && cloudwatch_cpu_credit_balance !== undefined) {
      var cloudwatch_cpu_credit_balance_avg = parseFloat(cloudwatch_cpu_credit_balance.avg).toFixed(2)
      var cloudwatch_cpu_credit_balance_min = parseFloat(cloudwatch_cpu_credit_balance.min).toFixed(2)
      var cloudwatch_cpu_credit_balance_max = parseFloat(cloudwatch_cpu_credit_balance.max).toFixed(2)
    } else {
      var cloudwatch_cpu_credit_balance_avg = "N/A"
      var cloudwatch_cpu_credit_balance_min = "N/A"
      var cloudwatch_cpu_credit_balance_max = "N/A"
    }

    if (cloudwatch_cpu_surplus_credit_balance != null && cloudwatch_cpu_surplus_credit_balance !== undefined) {
      var cloudwatch_cpu_surplus_credit_balance_avg = parseFloat(cloudwatch_cpu_surplus_credit_balance.avg).toFixed(2)
      var cloudwatch_cpu_surplus_credit_balance_min = parseFloat(cloudwatch_cpu_surplus_credit_balance.min).toFixed(2)
      var cloudwatch_cpu_surplus_credit_balance_max = parseFloat(cloudwatch_cpu_surplus_credit_balance.max).toFixed(2)
    } else {
      var cloudwatch_cpu_surplus_credit_balance_avg = "N/A"
      var cloudwatch_cpu_surplus_credit_balance_min = "N/A"
      var cloudwatch_cpu_surplus_credit_balance_max = "N/A"
    }

    if (cloudwatch_cpu_surplus_credits_charged != null && cloudwatch_cpu_surplus_credits_charged !== undefined) {
      var cloudwatch_cpu_surplus_credits_charged_avg = parseFloat(cloudwatch_cpu_surplus_credits_charged.avg).toFixed(2)
      var cloudwatch_cpu_surplus_credits_charged_min = parseFloat(cloudwatch_cpu_surplus_credits_charged.min).toFixed(2)
      var cloudwatch_cpu_surplus_credits_charged_max = parseFloat(cloudwatch_cpu_surplus_credits_charged.max).toFixed(2)
    } else {
      var cloudwatch_cpu_surplus_credits_charged_avg = "N/A"
      var cloudwatch_cpu_surplus_credits_charged_min = "N/A"
      var cloudwatch_cpu_surplus_credits_charged_max = "N/A"
    }

    merged_results.push(
      {
        "region": ds_cloudwatch_cpu_usage[i].region,
        "instanceId": ds_cloudwatch_cpu_usage[i].instanceId,
        "instanceType": ds_cloudwatch_cpu_usage[i].instanceType,
        "instance_type_info": ds_cloudwatch_cpu_usage[i].instance_type_info,
        "privateDnsName": ds_cloudwatch_cpu_usage[i].privateDnsName,
        "hostname": ds_cloudwatch_cpu_usage[i].privateDnsName.split('.')[0],
        "tag_set": ds_cloudwatch_cpu_usage[i].tag_set,
        "cpu_minimum": parseFloat(ds_cloudwatch_cpu_usage[i].cpu_minimum).toFixed(2),
        "cpu_maximum": parseFloat(ds_cloudwatch_cpu_usage[i].cpu_maximum).toFixed(2),
        "cpu_average": parseFloat(ds_cloudwatch_cpu_usage[i].cpu_average).toFixed(2),
        "cloudwatch_cpu_credit_balance_avg": cloudwatch_cpu_credit_balance_avg,
        "cloudwatch_cpu_credit_balance_max": cloudwatch_cpu_credit_balance_max,
        "cloudwatch_cpu_credit_balance_min": cloudwatch_cpu_credit_balance_min,
        "cloudwatch_cpu_surplus_credit_balance_avg": cloudwatch_cpu_surplus_credit_balance_avg,
        "cloudwatch_cpu_surplus_credit_balance_max": cloudwatch_cpu_surplus_credit_balance_max,
        "cloudwatch_cpu_surplus_credit_balance_min": cloudwatch_cpu_surplus_credit_balance_min,
        "cloudwatch_cpu_surplus_credits_charged_avg": cloudwatch_cpu_surplus_credits_charged_avg,
        "cloudwatch_cpu_surplus_credits_charged_min": cloudwatch_cpu_surplus_credits_charged_min,
        "cloudwatch_cpu_surplus_credits_charged_max": cloudwatch_cpu_surplus_credits_charged_max
      }
    )
  }
  merged_results = _.sortBy(merged_results, 'region');
EOS
end

datasource "ds_check_merged_metrics" do
  run_script $js_check_merged_metrics, $ds_merged_metrics, $param_cpu_burst_credit_balance, $param_cpu_surplus_credits, $ds_get_caller_identity
end

script "js_check_merged_metrics", type: "javascript" do
  parameters "ds_merged_metrics", "param_cpu_burst_credit_balance", "param_cpu_surplus_credits", "ds_get_caller_identity"
  result "merged_results"
  code <<-EOS
    var merged_results = []
    _.each(ds_merged_metrics,function(result) {
      if ( result.instance_type_info.burst_info !== undefined ){
        if ( param_cpu_burst_credit_balance == "true" && (result.cloudwatch_cpu_credit_balance_min != "N/A") && (result.cloudwatch_cpu_credit_balance_min == result.instance_type_info.burst_info.max_earnable_credits)){
          merged_results.push(
            {
              "accountId": ds_get_caller_identity[0]['account'],
              "region": result.region,
              "id": result.instanceId,
              "instanceType": result.instanceType,
              "instance_type_info": result.instance_type_info,
              "privateDnsName": result.privateDnsName,
              "hostname": result.hostname,
              "tag_set": result.tag_set,
              "cpu_minimum": result.cpu_minimum,
              "cpu_maximum": result.cpu_maximum,
              "cpu_average": result.cpu_average,
              "cloudwatch_cpu_credit_balance_avg": result.cloudwatch_cpu_credit_balance_avg,
              "cloudwatch_cpu_credit_balance_max": result.cloudwatch_cpu_credit_balance_max,
              "cloudwatch_cpu_credit_balance_min": result.cloudwatch_cpu_credit_balance_min,
              "cloudwatch_cpu_surplus_credit_balance_avg": result.cloudwatch_cpu_surplus_credit_balance_avg,
              "cloudwatch_cpu_surplus_credit_balance_max": result.cloudwatch_cpu_surplus_credit_balance_max,
              "cloudwatch_cpu_surplus_credit_balance_min": result.cloudwatch_cpu_surplus_credit_balance_min,
              "cloudwatch_cpu_surplus_credits_charged_avg": result.cloudwatch_cpu_surplus_credits_charged_avg,
              "cloudwatch_cpu_surplus_credits_charged_min": result.cloudwatch_cpu_surplus_credits_charged_min,
              "cloudwatch_cpu_surplus_credits_charged_max": result.cloudwatch_cpu_surplus_credits_charged_max,
              "next_instance_size": result.instance_type_info["down"]
            }
          )
        }
      }

      if ( param_cpu_surplus_credits != -1 && (result.cloudwatch_cpu_surplus_credit_balance_min != "N/A") && (result.cloudwatch_cpu_surplus_credit_balance_min >= param_cpu_surplus_credits)){
        merged_results.push(
          {
            "accountId": ds_get_caller_identity[0]['account'],
            "region": result.region,
            "id": result.instanceId,
            "instanceType": result.instanceType,
            "instance_type_info": result.instance_type_info,
            "privateDnsName": result.privateDnsName,
            "hostname": result.hostname,
            "tag_set": result.tag_set,
            "cpu_minimum": result.cpu_minimum,
            "cpu_maximum": result.cpu_maximum,
            "cpu_average": result.cpu_average,
            "cloudwatch_cpu_credit_balance_avg": result.cloudwatch_cpu_credit_balance_avg,
            "cloudwatch_cpu_credit_balance_max": result.cloudwatch_cpu_credit_balance_max,
            "cloudwatch_cpu_credit_balance_min": result.cloudwatch_cpu_credit_balance_min,
            "cloudwatch_cpu_surplus_credit_balance_avg": result.cloudwatch_cpu_surplus_credit_balance_avg,
            "cloudwatch_cpu_surplus_credit_balance_max": result.cloudwatch_cpu_surplus_credit_balance_max,
            "cloudwatch_cpu_surplus_credit_balance_min": result.cloudwatch_cpu_surplus_credit_balance_min,
            "cloudwatch_cpu_surplus_credits_charged_avg": result.cloudwatch_cpu_surplus_credits_charged_avg,
            "cloudwatch_cpu_surplus_credits_charged_min": result.cloudwatch_cpu_surplus_credits_charged_min,
            "cloudwatch_cpu_surplus_credits_charged_max": result.cloudwatch_cpu_surplus_credits_charged_max,
            "next_instance_size": result.instance_type_info["up"]
          }
        )
      }
    })
  EOS
end

###############################################################################
# Policy
###############################################################################

policy "pol_utilization" do
  validate $ds_check_merged_metrics do
    summary_template "AWS Account ID: {{with index data 0}}{{ .accountId }}{{end}} - {{ len data }} rows containing instance CloudWatch utilization data"
    export do
      resource_level true
      field "accountId" do
        label "Account Id"
      end
      field "region" do
        label "Region"
      end
      field "id" do
        label "Instance ID"
      end
      field "instanceType" do
        label "Instance Type"
      end
      field "hostname" do
        label "Hostname"
      end
      field "privateDnsName" do
        label "Private DNS Name"
      end
      field "cpu_maximum" do
        label "CPU Maximum %"
      end
      field "cpu_average" do
        label "CPU Average %"
      end
      field "cloudwatch_cpu_credit_balance_min" do
        label "CPU Credit Balance Minimum"
      end
      field "cloudwatch_cpu_surplus_credit_balance_min" do
        label "CPU Surplus Credit Balance Minimum"
      end
      field "cloudwatch_cpu_surplus_credits_charged_max" do
        label "CPU Surplus Credit Charged Maximum"
      end
      field "instance_type_info_burst_info_max_earnable_credits" do
        label "Max Earnable Credits"
        path "instance_type_info.burst_info.max_earnable_credits"
      end
      field "next_instance_size" do
        label "Resize Instance To"
      end
    end

    escalate $esc_email
    escalate $esc_resize_instance
    check eq(size(data), 0)
  end
end

###############################################################################
# Escalations
###############################################################################

escalation "esc_email" do
  automatic true
  label "Send Email"
  description "Send incident email"
  email $param_email
end

escalation "esc_resize_instance" do
  automatic contains($param_automatic_action, "Resize Instances")
  label "Resize Instances"
  description "Resize selected instances"
  run "resize_instances", data, $param_cooldown_days, rs_optima_host
end


###############################################################################
# Cloud Workflow
###############################################################################

define resize_instances($data,$param_cooldown_days, $$rs_optima_host) do
  foreach $item in $data do

    @current_instance = rs_cm.instances.empty()
    @instance = rs_cm.instances.index(filter: ["resource_uid=="+$item["id"]])
    @cloud = @instance.cloud()
    @next_instance = @instance

    if $item["next_instance_size"] != "N/A"
      sub on_error: rollback($item, @next_instance, @cloud) do
        call sys_log('Instance Resizing',$item['id'])
        call stop_instance(@instance, @cloud, $item) retrieve @next_instance

        @next_instance = first(@cloud.instances(filter: ['resource_uid=='+$item['id']]))
        @new_instance_type = first(@cloud.instance_types(filter: ["name=="+$item["next_instance_size"]]))
        @next_instance.update(instance: { instance_type_href: @new_instance_type.href })

        call sys_log('Instance Resized', @new_instance_type.name)
        call start_instance(@next_instance, @cloud, $item) retrieve @next_instance
      end

      sub task_label:"Adding Cooldown Tag" do
        $date = now() + (60*60*24)*$param_cooldown_days
        $format_string = "%Y/%m/%d %H:%M:%S"
        $formatted_time = strftime($date, $format_string)
        # add the cooldown tag, but
        # dont add/modify the cooldown tag if it already exists
        $cooldown_tag = tag_value(@next_instance,'rs_downsize:cooldown')
        call sys_log('cooldown_tag',$cooldown_tag)

        if !$cooldown_tag
          task_label("Adding Cooldown Tag " + $item['id'])
          rs_cm.tags.multi_add(resource_hrefs: [@next_instance.href], tags: ["rs_downsize:cooldown="+$formatted_time])
          call sys_log('Adding Cooldown Tag',$formatted_time)
        end
        @current_instance = @next_instance
      end
    end
  end
end

define rollback($item, @instance, @cloud) do
  sub task_label:"Rolling Back to Original Instance Type" do
    ## Logic to revert the instance back to its original instance type
    call sys_log('Instance Rollingback', $item['id'])
    @instance = first(@cloud.instances(filter: ['resource_uid=='+$item['id'] ]))

    sub task_label:"Setting Error Tag" do
      $msg = split($_error["message"], "\n")
      foreach $i in $msg do
        if $i =~ "CloudException"
          $tag = "rs_policy_action:downsize_error_info=" + $i
          rs_cm.tags.multi_add(tags: [$tag], resource_hrefs: [@instance.href])
        end
      end
      call sys_log(join(["Resize Error: ",@instance.name]), to_s($msg))
    end

    $state = @instance.state
    $current_instance_type = @instance.instance_type().name
    $started_condition = "/^(stranded|stranded in booting|error|operational|running)$/"
    if $current_instance_type == $item["instanceType"]
      # Instance is still the original size, just make sure it's running
      if $state =~ $started_condition
        # instance is running nothing to do
      else
        # instance is not running, start it
        call start_instance(@instance, @cloud, $item) retrieve @instance
      end
    else
      # Instance is the new size, roll back
      call sys_log('Instance Resizing', $item['id'])
      call stop_instance(@instance, @cloud, $item) retrieve @instance

      @instance = first(@cloud.instances(filter: ['resource_uid=='+$item['id']]))
      @new_instance_type = first(@cloud.instance_types(filter: ["name=="+$item["instanceType"]]))
      @instance.update(instance: { instance_type_href: @new_instance_type.href })

      call sys_log('Instance Resized', @new_instance_type.name)
      call start_instance(@instance, @cloud, $item) retrieve @instance
    end
  end
  $_error_behavior = "skip"
end

define stop_instance(@instance, @cloud, $item) return @instance do
  task_label("Stopping instance " + $item['id'])
  @instance.stop()
  task_label("Sleeping until instance stopped " + $item['id'])
  $wake_condition = "/^(stopped|terminated|inactive|error|provisioned)$/"
  $state = ''
  while $state !~ $wake_condition do
    sub on_error: retry, timeout: 20m, on_timeout: skip do
      # find the resource by resource_uid because the href may have changed after resize.
      @instance = first(@cloud.instances(filter: ['resource_uid=='+$item['id']]))
      call sys_log('Waiting for instance stop state: ' + @instance.name,to_s(to_object(@instance)))
      $state = @instance.state
      call sys_log('Instance stop state',$state)
    end
  end
  task_label("Instance Stopped " + $item['id'])
  call sys_log('Instance Stopped', $item['id'])
end

define start_instance(@instance, @cloud, $item) return @instance do
  task_label("Starting instance " + $item['id'])
  @instance.start()
  $wake_condition = "/^(stranded|stranded in booting|error|operational|running)$/"
  $state = ''
  task_label("Sleeping until instance started " + @next_instance.name)
  while $state !~ $wake_condition do
    sub on_error: retry, timeout: 20m, on_timeout: skip do
      # find the resource by resource_uid because the href may have changed after resize.
      @instance = first(@cloud.instances(filter: ['resource_uid=='+$item['id']]))
      call sys_log('waiting for instance start state', to_s(to_object(@instance)))
      $state = @instance.state
      call sys_log('Instance start state', $state)
    end
  end
  task_label("Instance Started " + $item['id'])
  call sys_log('Instance Started', $item['id'])
end

# remove the cooldown tag if the $param_cooldown_days has exceeded
define delete_cooldown_tag($data,$param_cooldown_days) do
  foreach $item in $data['cooldown_instances'] do
    @cloud = rs_cm.get(href: $item['cloud_href'])
    # find the resource by resource_uid because the href may have changed after resize.
    @instance = first(@cloud.instances(filter: ['resource_uid=='+$item['instanceId'] ]))
    $cooldown_tag = tag_value(@instance,'rs_downsize:cooldown')
    call sys_log('cooldown_tag',$cooldown_tag)
    $cooldown_time = to_d($cooldown_tag)
    call sys_log('cooldown_time',to_s($cooldown_time))
    # if the cooldown_time has passed delete the cooldown tag
    if ($cooldown_time - now()) / 86400 >= $param_cooldown_days
      rs_cm.tags.multi_delete(resource_hrefs: [@instance.href], tags: 'rs_downsize:cooldown')
      call sys_log('deleted cooldown tag',$cooldown_value)
    end
  end
end

define sys_log($subject, $detail) do
  # Create empty errors array if doesn't already exist
  if !$$errors
    $$errors = []
  end
  # Check if debug is enabled
  if $$debug
    # Append to global $$errors
    # This is the suggested way to capture errors
    $$errors << "Unexpected error for " + $subject + "\n  " + to_s($detail)
    # If Flexera NAM Zone, create audit_entries [to be deprecated]
    # This is the legacy method for capturing errors and only supported on Flexera NAM
    if $$rs_optima_host == "api.optima.flexeraeng.com"
      # skip_error_and_append is used to catch error if rs_cm.audit_entries.create fails unexpectedly
      $task_label = "Creating audit entry for " + $subject
      sub task_label: $task, on_error: skip_error_and_append($task) do
        rs_cm.audit_entries.create(
          notify: "None",
          audit_entry: {
            auditee_href: @@account,
            summary: $subject,
            detail: $detail
          }
        )
      end # End sub on_error
    end # End if rs_optima_host
  end # End if debug is enabled
end

define skip_error_and_append($subject) do
  $$errors << "Unexpected error for " + $subject + "\n  " + to_s($_error)
  $_error_behavior = "skip"
end
