name "Google BigQuery Optimization"
rs_pt_ver 20180301
type "policy"
short_description "Identifies BigQuery tables with compute and storage optimization opportunities. See the [README](https://github.com/flexera-public/policy_templates/tree/master/cost/google/bigquery_optimization/) and [docs.flexera.com/flexera/EN/Automation](https://docs.flexera.com/flexera/EN/Automation/AutomationGS.htm) to learn more."
long_description ""
doc_link "https://github.com/flexera-public/policy_templates/tree/master/cost/google/bigquery_optimization/"
category "Cost"
severity "low"
default_frequency "weekly"
info(
  version: "0.1.0",
  provider:"Google",
  service: "BigQuery",
  policy_set: "Storage Optimization",
  recommendation_type: "Usage Reduction",
  hide_skip_approvals: "true"
)

###############################################################################
# Parameters
###############################################################################

parameter "param_email" do
  type "list"
  category "Policy Settings"
  label "Email Addresses"
  description "A list of email addresses to notify."
  default []
end

parameter "param_min_savings" do
  type "number"
  category "Policy Settings"
  label "Minimum Savings Threshold"
  description "Minimum potential monthly savings required to generate a recommendation"
  min_value 0
  default 0
end

parameter "param_long_term_threshold_days" do
  type "number"
  category "Storage Optimization"
  label "Long-Term Storage Threshold (Days)"
  description "Number of days since last modification to consider moving data to long-term storage"
  min_value 30
  default 90
end

parameter "param_min_table_size_gb" do
  type "number"
  category "Storage Optimization"
  label "Minimum Table Size for Partitioning (GB)"
  description "Minimum table size in GB to recommend partitioning optimizations"
  min_value 0
  default 1
end

parameter "param_enable_query_analysis" do
  type "string"
  category "Query Analysis"
  label "Enable Query Analysis"
  description "Enable detailed query analysis for additional recommendations and savings calculations. Requires permission to create job in BigQuery datasets."
  allowed_values "Enable Query Analysis", "Disable Query Analysis"
  default "Disable Query Analysis"
end

parameter "param_query_lookback_days" do
  type "number"
  category "Query Analysis"
  label "Query Analysis Lookback Period (Days)"
  description "Number of days to analyze historical query patterns for savings calculations (1-180 days)"
  min_value 1
  max_value 180
  default 30
end

parameter "param_projects_allow_or_deny" do
  type "string"
  category "Filters"
  label "Allow/Deny Projects"
  description "Allow or Deny entered Projects. See the README for more details."
  allowed_values "Allow", "Deny"
  default "Allow"
end

parameter "param_projects_list" do
  type "list"
  category "Filters"
  label "Allow/Deny Projects List"
  description "A list of allowed or denied Project IDs/names. See the README for more details."
  default []
end

parameter "param_projects_ignore_sys" do
  type "string"
  category "Filters"
  label "Ignore System Projects"
  description "Whether or not to automatically ignore system projects e.g. projects whose id begins with 'sys-'"
  allowed_values "Yes", "No"
  default "Yes"
end

parameter "param_projects_ignore_app" do
  type "string"
  category "Filters"
  label "Ignore Google Apps Script Projects"
  description "Whether or not to automatically ignore Google Apps Script projects e.g. projects whose id begins with 'app-'"
  allowed_values "Yes", "No"
  default "Yes"
end

###############################################################################
# Authentication
###############################################################################

credentials "auth_google" do
  schemes "oauth2"
  label "Google"
  description "Select the Google Cloud Credential from the list."
  tags "provider=gce"
end

credentials "auth_flexera" do
  schemes "oauth2"
  label "Flexera"
  description "Select Flexera One OAuth2 credentials"
  tags "provider=flexera"
end

###############################################################################
# Pagination
###############################################################################

pagination "pagination_google" do
  get_page_marker do
    body_path "nextPageToken"
  end
  set_page_marker do
    query "pageToken"
  end
end

###############################################################################
# Datasources & Scripts
###############################################################################

# Get region-specific Flexera API endpoints
datasource "ds_flexera_api_hosts" do
  run_script $js_flexera_api_hosts, rs_optima_host
end

script "js_flexera_api_hosts", type: "javascript" do
  parameters "rs_optima_host"
  result "result"
  code <<-EOS
  host_table = {
    "api.optima.flexeraeng.com": {
      api: "api.flexera.com",
      flexera: "api.flexera.com",
      fsm: "api.fsm.flexeraeng.com",
      grs: "grs-front.iam-us-east-1.flexeraeng.com",
      ui: "app.flexera.com",
      tld: "flexera.com"
    },
    "api.optima-eu.flexeraeng.com": {
      api: "api.flexera.eu",
      flexera: "api.flexera.eu",
      fsm: "api.fsm-eu.flexeraeng.com",
      grs: "grs-front.eu-central-1.iam-eu.flexeraeng.com",
      ui: "app.flexera.eu",
      tld: "flexera.eu"
    },
    "api.optima-apac.flexeraeng.com": {
      api: "api.flexera.au",
      flexera: "api.flexera.au",
      fsm: "api.fsm-apac.flexeraeng.com",
      grs: "grs-front.ap-southeast-2.iam-apac.flexeraeng.com",
      ui: "app.flexera.au",
      tld: "flexera.au"
    }
  }

  result = host_table[rs_optima_host]
EOS
end

# Table to derive region from zone
datasource "ds_zone_to_region" do
  run_script $js_zone_to_region
end

script "js_zone_to_region", type:"javascript" do
  result "result"
  code <<-EOS
  result = {
    "us-east1-b": "us-east1",
    "us-east1-c": "us-east1",
    "us-east1-d": "us-east1",
    "us-east4-c": "us-east4",
    "us-east4-b": "us-east4",
    "us-east4-a": "us-east4",
    "us-central1-c": "us-central1",
    "us-central1-a": "us-central1",
    "us-central1-f": "us-central1",
    "us-central1-b": "us-central1",
    "us-west1-b": "us-west1",
    "us-west1-c": "us-west1",
    "us-west1-a": "us-west1",
    "europe-west4-a": "europe-west4",
    "europe-west4-b": "europe-west4",
    "europe-west4-c": "europe-west4",
    "europe-west1-b": "europe-west1",
    "europe-west1-d": "europe-west1",
    "europe-west1-c": "europe-west1",
    "europe-west3-c": "europe-west3",
    "europe-west3-a": "europe-west3",
    "europe-west3-b": "europe-west3",
    "europe-west2-c": "europe-west2",
    "europe-west2-b": "europe-west2",
    "europe-west2-a": "europe-west2",
    "asia-east1-b": "asia-east1",
    "asia-east1-a": "asia-east1",
    "asia-east1-c": "asia-east1",
    "asia-southeast1-b": "asia-southeast1",
    "asia-southeast1-a": "asia-southeast1",
    "asia-southeast1-c": "asia-southeast1",
    "asia-northeast1-b": "asia-northeast1",
    "asia-northeast1-c": "asia-northeast1",
    "asia-northeast1-a": "asia-northeast1",
    "asia-south1-c": "asia-south1",
    "asia-south1-b": "asia-south1",
    "asia-south1-a": "asia-south1",
    "australia-southeast1-b": "australia-southeast1",
    "australia-southeast1-c": "australia-southeast1",
    "australia-southeast1-a": "australia-southeast1",
    "southamerica-east1-b": "southamerica-east1",
    "southamerica-east1-c": "southamerica-east1",
    "southamerica-east1-a": "southamerica-east1",
    "asia-east2-a": "asia-east2",
    "asia-east2-b": "asia-east2",
    "asia-east2-c": "asia-east2",
    "asia-northeast2-a": "asia-northeast2",
    "asia-northeast2-b": "asia-northeast2",
    "asia-northeast2-c": "asia-northeast2",
    "asia-northeast3-a": "asia-northeast3",
    "asia-northeast3-b": "asia-northeast3",
    "asia-northeast3-c": "asia-northeast3",
    "asia-south2-a": "asia-south2",
    "asia-south2-b": "asia-south2",
    "asia-south2-c": "asia-south2",
    "asia-southeast2-a": "asia-southeast2",
    "asia-southeast2-b": "asia-southeast2",
    "asia-southeast2-c": "asia-southeast2",
    "australia-southeast2-a": "australia-southeast2",
    "australia-southeast2-b": "australia-southeast2",
    "australia-southeast2-c": "australia-southeast2",
    "europe-central2-a": "europe-central2",
    "europe-central2-b": "europe-central2",
    "europe-central2-c": "europe-central2",
    "europe-north1-a": "europe-north1",
    "europe-north1-b": "europe-north1",
    "europe-north1-c": "europe-north1",
    "europe-southwest1-a": "europe-southwest1",
    "europe-southwest1-b": "europe-southwest1",
    "europe-southwest1-c": "europe-southwest1",
    "europe-west6-a": "europe-west6",
    "europe-west6-b": "europe-west6",
    "europe-west6-c": "europe-west6",
    "northamerica-northeast1-a": "northamerica-northeast1",
    "northamerica-northeast1-b": "northamerica-northeast1",
    "northamerica-northeast1-c": "northamerica-northeast1",
    "northamerica-northeast2-a": "northamerica-northeast2",
    "northamerica-northeast2-b": "northamerica-northeast2",
    "northamerica-northeast2-c": "northamerica-northeast2",
    "us-west2-a": "us-west2",
    "us-west2-b": "us-west2",
    "us-west2-c": "us-west2",
    "us-west3-a": "us-west3",
    "us-west3-b": "us-west3",
    "us-west3-c": "us-west3",
    "us-west4-a": "us-west4",
    "us-west4-b": "us-west4",
    "us-west4-c": "us-west4",
    "us-west5-a": "us-west5",
    "us-west5-b": "us-west5",
    "us-west5-c": "us-west5",
    "us-west6-a": "us-west6",
    "us-west6-b": "us-west6",
    "us-west6-c": "us-west6",
    "us-west7-a": "us-west7",
    "us-west7-b": "us-west7",
    "us-west7-c": "us-west7"
  }
EOS
end

# Get applied policy metadata for use later
datasource "ds_applied_policy" do
  request do
    auth $auth_flexera
    host val($ds_flexera_api_hosts, "flexera")
    path join(["/policy/v1/orgs/", rs_org_id, "/projects/", rs_project_id, "/applied-policies", switch(policy_id, join(["/", policy_id]), "")])
  end
end

# Gather local currency info
datasource "ds_currency_reference" do
  request do
    host "raw.githubusercontent.com"
    path "/flexera-public/policy_templates/master/data/currency/currency_reference.json"
    header "User-Agent", "RS Policies"
  end
end

datasource "ds_currency_code" do
  request do
    auth $auth_flexera
    host rs_optima_host
    path join(["/bill-analysis/orgs/", rs_org_id, "/settings/currency_code"])
    header "Api-Version", "0.1"
    header "User-Agent", "RS Policies"
    ignore_status [403]
  end
  result do
    encoding "json"
    field "id", jmes_path(response, "id")
    field "value", jmes_path(response, "value")
  end
end

datasource "ds_currency_target" do
  run_script $js_currency_target, $ds_currency_reference, $ds_currency_code
end

script "js_currency_target", type:"javascript" do
  parameters "ds_currency_reference", "ds_currency_code"
  result "result"
  code <<-EOS
  // Default to USD if currency is not found
  result = ds_currency_reference['USD']

  if (ds_currency_code['value'] != undefined && ds_currency_reference[ds_currency_code['value']] != undefined) {
    result = ds_currency_reference[ds_currency_code['value']]
  }
EOS
end

# Branching logic:
# This datasource returns an empty array if the target currency is USD.
# This prevents ds_currency_conversion from running if it's not needed.
datasource "ds_conditional_currency_conversion" do
  run_script $js_conditional_currency_conversion, $ds_currency_target
end

script "js_conditional_currency_conversion", type: "javascript" do
  parameters "ds_currency_target"
  result "result"
  code <<-EOS
  result = []
  // Make the request only if the target currency is not USD
  if (ds_currency_target['code'] != 'USD') {
    result = [1]
  }
EOS
end

datasource "ds_currency_conversion" do
  # Only make a request if the target currency is not USD
  iterate $ds_conditional_currency_conversion
  request do
    host "api.xe-auth.flexeraeng.com"
    path "/prod/{proxy+}"
    query "from", "USD"
    query "to", val($ds_currency_target, 'code')
    query "amount", "1"
    # Ignore currency conversion if API has issues
    ignore_status [400, 404, 502]
  end
  result do
    encoding "json"
    field "from", jmes_path(response, "from")
    field "to", jmes_path(response, "to")
    field "amount", jmes_path(response, "amount")
    field "year", jmes_path(response, "year")
  end
end

datasource "ds_currency" do
  run_script $js_currency, $ds_currency_target, $ds_currency_conversion
end

script "js_currency", type:"javascript" do
  parameters "ds_currency_target", "ds_currency_conversion"
  result "result"
  code <<-EOS
  result = ds_currency_target
  result['exchange_rate'] = 1

  if (ds_currency_conversion.length > 0) {
    currency_code = ds_currency_target['code']
    current_month = parseInt(new Date().toISOString().split('-')[1])

    conversion_block = _.find(ds_currency_conversion[0]['to'][currency_code], function(item) {
      return item['month'] == current_month
    })

    if (conversion_block != undefined) {
      result['exchange_rate'] = conversion_block['monthlyAverage']
    }
  }
EOS
end

datasource "ds_google_projects" do
  request do
    auth $auth_google
    pagination $pagination_google
    host "bigquery.googleapis.com"
    path "/bigquery/v2/projects"
    # Header X-Meta-Flexera has no affect on datasource query, but is required for Meta Policies
    # Forces `ds_is_deleted` datasource to run first during policy execution
    header "Meta-Flexera", val($ds_is_deleted, "path")
  end
  result do
    encoding "json"
    collect jmes_path(response, "projects[*]") do
      field "number", jmes_path(col_item, "numericId")
      field "id", jmes_path(col_item, "id")
      field "name", jmes_path(col_item, "friendlyName")
    end
  end
end

datasource "ds_google_projects_filtered" do
  run_script $js_google_projects_filtered, $ds_google_projects, $param_projects_allow_or_deny, $param_projects_list, $param_projects_ignore_sys, $param_projects_ignore_app
end

script "js_google_projects_filtered", type: "javascript" do
  parameters "ds_google_projects", "param_projects_allow_or_deny", "param_projects_list", "param_projects_ignore_sys", "param_projects_ignore_app"
  result "result"
  code <<-EOS
  if (param_projects_list.length > 0) {
    filtered = _.filter(ds_google_projects, function(project) {
      include_project = _.contains(param_projects_list, project['id']) || _.contains(param_projects_list, project['name']) || _.contains(param_projects_list, project['number'])

      if (param_projects_allow_or_deny == "Deny") {
        include_project = !include_project
      }

      return include_project
    })
  } else {
    filtered = ds_google_projects
  }

  result = _.reject(filtered, function(project) {
    return (project['id'].substring(0, 4) == "sys-" && param_projects_ignore_sys == "Yes") || (project['id'].substring(0, 4) == "app-" && param_projects_ignore_app == "Yes")
  })
EOS
end

datasource "ds_google_bigquery_datasets" do
  iterate $ds_google_projects_filtered
  request do
    auth $auth_google
    pagination $pagination_google
    host "bigquery.googleapis.com"
    path join(["/bigquery/v2/projects/", val(iter_item, "id"), "/datasets"])
    ignore_status [403, 404, 400] # Ignore status 400 "Has not Enabled BigQuery"
  end
  result do
    encoding "json"
    collect jmes_path(response, "datasets[*]") do
      field "id", jmes_path(col_item, "id")
      field "datasetId", jmes_path(col_item, "datasetReference.datasetId")
      field "friendlyName", jmes_path(col_item, "friendlyName")
      field "location", jmes_path(col_item, "location")
      field "kind", jmes_path(col_item, "kind")
      field "projectId", val(iter_item, "id")
      field "projectName", val(iter_item, "name")
      field "projectNumber", val(iter_item, "number")
    end
  end
end

datasource "ds_google_bigquery_tables" do
  iterate $ds_google_bigquery_datasets
  request do
    auth $auth_google
    pagination $pagination_google
    host "bigquery.googleapis.com"
    path join(["/bigquery/v2/projects/", val(iter_item, "projectId"), "/datasets/", val(iter_item, "datasetId"), "/tables"])
    ignore_status [403, 404]
  end
  result do
    encoding "json"
    collect jmes_path(response, "tables[*]") do
      field "id", jmes_path(col_item, "id")
      field "tableId", jmes_path(col_item, "tableReference.tableId")
      field "datasetId", jmes_path(col_item, "tableReference.datasetId")
      field "projectId", jmes_path(col_item, "tableReference.projectId")
      field "creationTime", jmes_path(col_item, "creationTime")
      field "timePartitioning", jmes_path(col_item, "timePartitioning")
      field "rangePartitioning", jmes_path(col_item, "rangePartitioning")
      field "clustering", jmes_path(col_item, "clustering")
      field "hivePartitioningOptions", jmes_path(col_item, "hivePartitioningOptions")
      field "expirationTime", jmes_path(col_item, "expirationTime")
      field "type", jmes_path(col_item, "type")
      field "view", jmes_path(col_item, "view")
      field "location", val(iter_item, "location")
    end
  end
end

datasource "ds_google_bigquery_tables_details" do
  iterate $ds_google_bigquery_tables
  request do
    auth $auth_google
    pagination $pagination_google
    host "bigquery.googleapis.com"
    # https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/get
    # GET https://bigquery.googleapis.com/bigquery/v2/projects/{projectId}/datasets/{datasetId}/tables/{tableId}
    path join(["/bigquery/v2/projects/", val(iter_item, "projectId"), "/datasets/", val(iter_item, "datasetId"), "/tables/", val(iter_item, "tableId")])
    query "view", "FULL" # Get full table metadata
    ignore_status [403, 404]
  end
  result do
    encoding "json"
    # https://cloud.google.com/bigquery/docs/reference/rest/v2/tables#Table
    # https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/get
    collect jmes_path(response, "@") do
      field "iter_item_id", jmes_path(iter_item, "id")
      # field "table_details_raw", jmes_path(col_item, "@") # For dev/debug only
      field "numBytes", jmes_path(col_item, "numBytes")
      field "numLongTermBytes", jmes_path(col_item, "numLongTermBytes")
      field "numRows", jmes_path(col_item, "numRows")
      field "creationTime", jmes_path(col_item, "creationTime")
      field "expirationTime", jmes_path(col_item, "expirationTime") # No values in my testing
      field "lastModifiedTime", jmes_path(col_item, "lastModifiedTime")
      field "numTimeTravelPhysicalBytes", jmes_path(col_item, "numTimeTravelPhysicalBytes")
      field "numTotalLogicalBytes", jmes_path(col_item, "numTotalLogicalBytes")
      field "numActiveLogicalBytes", jmes_path(col_item, "numActiveLogicalBytes")
      field "numLongTermLogicalBytes", jmes_path(col_item, "numLongTermLogicalBytes")
      field "numTotalPhysicalBytes", jmes_path(col_item, "numTotalPhysicalBytes")
      field "numActivePhysicalBytes", jmes_path(col_item, "numActivePhysicalBytes")
      field "numLongTermPhysicalBytes", jmes_path(col_item, "numLongTermPhysicalBytes")
      field "numPartitions", jmes_path(col_item, "numPartitions")
      field "maxStaleness", jmes_path(col_item, "maxStaleness") # No values in my testing
      field "type", jmes_path(col_item, "type")
      field "view", jmes_path(col_item, "view")
      field "schema", jmes_path(col_item, "schema")
      field "timePartitioningDetails", jmes_path(col_item, "timePartitioning")
      field "rangePartitioningDetails", jmes_path(col_item, "rangePartitioning")
    end
  end
end

datasource "ds_bigquery_query_stats_enabled" do
  run_script $js_bigquery_query_stats_enabled, $param_enable_query_analysis, $ds_google_bigquery_datasets
end

script "js_bigquery_query_stats_enabled", type:"javascript" do
  parameters "param_enable_query_analysis", "ds_google_bigquery_datasets"
  result "result"
  code <<-EOS
  result = []
  // Only pass the list of datasets through if query analysis is enabled
  if (param_enable_query_analysis == "Enable Query Analysis") {
    result = ds_google_bigquery_datasets
  }
EOS
end

# Get query statistics per table from INFORMATION_SCHEMA.JOBS
# This provides actual query patterns for accurate savings calculations
datasource "ds_bigquery_query_stats" do
  iterate $ds_bigquery_query_stats_enabled
  request do
    auth $auth_google
    host "bigquery.googleapis.com"
    path join(["/bigquery/v2/projects/", val(iter_item, "projectId"), "/queries"])
    header "Content-Type", "application/json"
    body_field "query", join([
      "SELECT ",
      "  t.table_id,",
      "  t.dataset_id,",
      "  COUNT(*) as query_count,",
      "  AVG(total_bytes_processed) as avg_bytes_processed,",
      "  SUM(total_bytes_processed) as total_bytes_processed,",
      "  MAX(total_bytes_processed) as max_bytes_processed,",
      "  AVG(total_slot_ms) as avg_slot_ms ",
      "FROM `region-", val(iter_item, "location"), "`.INFORMATION_SCHEMA.JOBS, ",
      "  UNNEST(referenced_tables) AS t ",
      "WHERE t.project_id = '", val(iter_item, "projectId"), "' ",
      "  AND t.dataset_id = '", val(iter_item, "datasetId"), "' ",
      "  AND creation_time >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL ", $param_query_lookback_days, " DAY) ",
      "  AND job_type = 'QUERY' ",
      "  AND state = 'DONE' ",
      "  AND error_result IS NULL ",
      "  AND statement_type != 'SCRIPT' ",
      "GROUP BY t.table_id, t.dataset_id"
    ])
    body_field "useLegacySql", false
    verb "POST"
    ignore_status [403, 404, 400] # Ignore status for now to have policy do "best effort" instead of "all or nothing".  Would be good to compare datasets in a later datasource to understand which ones we were not able to get query status for.
  end
  result do
    encoding "json"
    collect jmes_path(response, "rows[*]") do
      field "tableId", jmes_path(col_item, "f[0].v")
      field "datasetId", jmes_path(col_item, "f[1].v")
      field "queryCount", jmes_path(col_item, "f[2].v")
      field "avgBytesProcessed", jmes_path(col_item, "f[3].v")
      field "totalBytesProcessed", jmes_path(col_item, "f[4].v")
      field "maxBytesProcessed", jmes_path(col_item, "f[5].v")
      field "avgSlotMs", jmes_path(col_item, "f[6].v")
      field "projectId", val(iter_item, "projectId")
      field "location", val(iter_item, "location")
    end
  end
end

# datasource "ds_google_bigquery_jobs" do
#   iterate $ds_google_bigquery_datasets
#   request do
#     auth $auth_google
#     # Do not paginate jobs request - we only want the most recent 100 jobs per dataset
#     host "bigquery.googleapis.com"
#     path join(["/bigquery/v2/projects/", val(iter_item, "projectId"), "/jobs"])
#     query "maxResults", "100" # 100 results
#     ignore_status [403, 404]
#   end
#   result do
#     encoding "json"
#     collect jmes_path(response, "jobs[*]") do
#       field "id", jmes_path(col_item, "id")
#       field "jobReference", jmes_path(col_item, "jobReference")
#       field "state", jmes_path(col_item, "status.state")
#       field "creationTime", jmes_path(col_item, "statistics.creationTime")
#       field "projectId", val(iter_item, "projectId")
#       field "datasetId", val(iter_item, "datasetId")
#     end
#   end
# end

datasource "ds_analyze_tables" do
  run_script $js_analyze_tables, $ds_google_bigquery_tables, $ds_google_bigquery_tables_details, $ds_bigquery_query_stats, $param_min_savings, $param_long_term_threshold_days, $param_min_table_size_gb, $param_query_lookback_days, $param_enable_query_analysis
end

script "js_analyze_tables", type:"javascript" do
  parameters "ds_google_bigquery_tables", "ds_google_bigquery_tables_details", "ds_bigquery_query_stats", "param_min_savings", "param_long_term_threshold_days", "param_min_table_size_gb", "param_query_lookback_days", "param_enable_query_analysis"
  result "result"
  code <<-'EOS'
  function endsWith(str, search) {
    return str.substring(str.length - search.length) === search;
  }
  // BigQuery Storage and Performance Optimization Analysis
  // This script implements 11 best practice checks from Google Cloud documentation:
  // 1. Long-term storage optimization (move old data to cheaper storage tier)
  // 2. Partitioning recommendations (add partitioning to large unpartitioned tables)
  // 3. Clustering recommendations (add clustering for query performance)
  // 4. Table expiration policies (prevent data accumulation)
  // 5. Time travel optimization (reduce time travel window costs)
  // 6. Large table review (flag very large tables for manual review)
  // 7. Avoid SELECT * in views (detect views without column pruning)
  // 8. Partition expiration settings (auto-delete old partitions)
  // 9. Date-sharded table detection (migrate date-suffixed tables to partitions)
  // 10. Table oversharding detection (consolidate excessive table shards)
  // 11. Primary/foreign key constraints (add missing constraints for query optimization)

  result = [];
  var currentTime = new Date().getTime();

  var debug = false; // Set to true for additional console logging

  // BigQuery pricing (as of 2025-11, in USD)
  // Source: https://cloud.google.com/bigquery/pricing
  // Storage pricing per GB per month:
  var ACTIVE_STORAGE_PRICE = 0.02;      // $0.02/GB/month for active logical storage
  var LONG_TERM_STORAGE_PRICE = 0.01;   // $0.01/GB/month for long-term logical storage (after 90 days)
  var PHYSICAL_STORAGE_PRICE = 0.04;    // $0.04/GB/month for active physical storage
  var LONG_TERM_PHYSICAL_STORAGE_PRICE = 0.02; // $0.02/GB/month for long-term physical storage

  // Compute pricing:
  var ON_DEMAND_PRICE_PER_TB = 6.25;    // $6.25 per TB processed (on-demand)
  var SLOT_PRICE_PER_HOUR = 0.04;       // ~$0.04 per slot-hour (Enterprise edition, approximate)

  // Conservative reduction factors for recommendations (evidence-based)
  // Source: https://cloud.google.com/bigquery/docs/best-practices-performance-compute
  var PARTITIONING_REDUCTION = 0.70;    // 70% reduction in bytes scanned (conservative)
  var CLUSTERING_REDUCTION = 0.25;      // 25% reduction in bytes scanned (conservative)
  var VIEW_COLUMN_REDUCTION = 0.35;     // 35% of columns typically unused (conservative)
  var TIME_TRAVEL_REDUCTION = 0.30;     // 30% reduction with optimized retention
  var SHARDING_OVERHEAD = 0.15;         // 15% query performance improvement

  // String constant if query analysis is enabled
  var queryAnalysisTip = ""
  if (param_enable_query_analysis == "Enable Query Analysis") {
    queryAnalysisTip = " (enable \"Query Analysis\" capability to calculate)"
  }

  // Basic pricing validation
  if (LONG_TERM_STORAGE_PRICE >= ACTIVE_STORAGE_PRICE) {
    console.log("Warning: Long-term storage price should be less than active storage price");
  }
  if (LONG_TERM_PHYSICAL_STORAGE_PRICE >= PHYSICAL_STORAGE_PRICE) {
    console.log("Warning: Long-term physical storage price should be less than active physical storage price");
  }

  // Build query stats lookup map for fast access
  var queryStatsMap = {};
  for (var i = 0; i < ds_bigquery_query_stats.length; i++) {
    var stat = ds_bigquery_query_stats[i];
    var key = stat.projectId + ":" + stat.datasetId + ":" + stat.tableId;
    queryStatsMap[key] = {
      queryCount: parseFloat(stat.queryCount || 0),
      avgBytesProcessed: parseFloat(stat.avgBytesProcessed || 0),
      totalBytesProcessed: parseFloat(stat.totalBytesProcessed || 0),
      maxBytesProcessed: parseFloat(stat.maxBytesProcessed || 0),
      avgSlotMs: parseFloat(stat.avgSlotMs || 0),
      hasData: true
    };
  }

  if (debug) {
    console.log("Query stats available for " + Object.keys(queryStatsMap).length + " tables");
  }

  for (var i = 0; i < ds_google_bigquery_tables.length; i++) {
    var table = ds_google_bigquery_tables[i];
    var recommendations = [];
    var potentialSavings = 0;
    var priority = "low";
    var savingsBreakdown = [];  // Track individual savings components
    var confidenceLevel = "high";  // Track overall confidence

    // Find matching table details
    var tableDetails = null;
    for (var j = 0; j < ds_google_bigquery_tables_details.length; j++) {
      if (ds_google_bigquery_tables_details[j].iter_item_id === table.id) {
        tableDetails = ds_google_bigquery_tables_details[j];
        break;
      }
    }

    if (!tableDetails) {
      continue; // Skip if no details found
    }

    // Get query stats for this table (if available)
    var tableKey = table.projectId + ":" + table.datasetId + ":" + table.tableId;
    var queryStats = queryStatsMap[tableKey] || {
      queryCount: 0,
      avgBytesProcessed: 0,
      hasData: false
    };

    // Calculate monthly query count from lookback period
    var queriesPerMonth = 0;
    if (queryStats.hasData && queryStats.queryCount > 0) {
      queriesPerMonth = (queryStats.queryCount / param_query_lookback_days) * 30;
    }

    // Convert bytes to GB for calculations
    var totalBytes = parseFloat(tableDetails.numBytes || 0);
    var activeBytes = parseFloat(tableDetails.numActiveLogicalBytes || 0);
    var longTermBytes = parseFloat(tableDetails.numLongTermLogicalBytes || 0);
    var physicalBytes = parseFloat(tableDetails.numTotalPhysicalBytes || 0);
    var timeTravelBytes = parseFloat(tableDetails.numTimeTravelPhysicalBytes || 0);

    var totalGB = totalBytes / (1024 * 1024 * 1024);
    var activeGB = activeBytes / (1024 * 1024 * 1024);
    var longTermGB = longTermBytes / (1024 * 1024 * 1024);
    var physicalGB = physicalBytes / (1024 * 1024 * 1024);
    var timeTravelGB = timeTravelBytes / (1024 * 1024 * 1024);

    // Calculate current monthly cost
    var currentCost = (activeGB * ACTIVE_STORAGE_PRICE) +
                     (longTermGB * LONG_TERM_STORAGE_PRICE) +
                     (physicalGB * PHYSICAL_STORAGE_PRICE);

    // 1. Long-term storage optimization
    if (tableDetails.lastModifiedTime) {
      var lastModified = parseFloat(tableDetails.lastModifiedTime);
      var daysSinceModified = (currentTime - lastModified) / (1000 * 60 * 60 * 24);

      if (daysSinceModified > param_long_term_threshold_days && activeGB > 0) {
        var longTermSavings = activeGB * (ACTIVE_STORAGE_PRICE - LONG_TERM_STORAGE_PRICE);
        if (longTermSavings > 0) {
          recommendations.push("Move " + activeGB.toFixed(2) + " GB from Active to Long-term Storage (not modified in " + Math.floor(daysSinceModified) + " days) - Calculated savings: $" + longTermSavings.toFixed(2) + "/month [HIGH CONFIDENCE]. See [Control Storage Costs > Use long-term storage](https://cloud.google.com/bigquery/docs/best-practices-costs#use_long-term_storage)");
          savingsBreakdown.push({
            type: "Storage Migration",
            amount: longTermSavings,
            confidence: "high"
          });
          potentialSavings += longTermSavings;
          priority = "high";
        }
      } else {
        if (debug) {
          console.log("Table " + table.id + " modified " + daysSinceModified.toFixed(1) + " days ago; skipping long-term storage recommendation");
        }
      }
    }

    // 2. Partitioning recommendations for large tables
    var minSizeGB = param_min_table_size_gb;
    if (totalGB > minSizeGB && !table.timePartitioning && !table.rangePartitioning && !table.hivePartitioningOptions) {
      // Phase 2: With query stats (high confidence)
      if (queryStats.hasData && queriesPerMonth > 0) {
        var avgBytesScannedGB = queryStats.avgBytesProcessed / (1024 * 1024 * 1024);
        var partitionSavings = (avgBytesScannedGB / 1024) * queriesPerMonth * PARTITIONING_REDUCTION * ON_DEMAND_PRICE_PER_TB;

        if (partitionSavings > 0.01) {
          recommendations.push("Add partitioning to reduce query costs by scanning 70% less data (table: " + totalGB.toFixed(2) + " GB, " + Math.round(queriesPerMonth) + " queries/month, avg " + avgBytesScannedGB.toFixed(2) + " GB scanned) - Calculated savings: $" + partitionSavings.toFixed(2) + "/month [HIGH CONFIDENCE]. See [Reduce data processed > Prune Partitioned Queries](https://cloud.google.com/bigquery/docs/best-practices-performance-compute#prune_partitioned_queries)");
          savingsBreakdown.push({
            type: "Partitioning",
            amount: partitionSavings,
            confidence: "high"
          });
          potentialSavings += partitionSavings;
          if (priority === "low") priority = "high";
        }
      } else {
        // Phase 1: Without query stats - don't estimate compute savings without data
        // Providing a compute cost estimate would be misleading since we don't know query patterns
        recommendations.push("Add partitioning to improve query performance for large table (" + totalGB.toFixed(2) + " GB) - potential savings depend on query patterns" + queryAnalysisTip + ". See [Reduce data processed > Prune Partitioned Queries](https://cloud.google.com/bigquery/docs/best-practices-performance-compute#prune_partitioned_queries)");
        confidenceLevel = "low";
        if (priority === "low") priority = "medium";
      }
    } else {
      if (debug) {
        console.log("Table " + table.id + " is already partitioned or too small (" + totalGB.toFixed(2) + " GB)");
      }
    }

    // 3. Clustering recommendations
    if (!table.clustering && totalGB > minSizeGB) {
      // Phase 2: With query stats (high confidence)
      if (queryStats.hasData && queriesPerMonth > 0) {
        var avgBytesScannedGB = queryStats.avgBytesProcessed / (1024 * 1024 * 1024);
        var clusterSavings = (avgBytesScannedGB / 1024) * queriesPerMonth * CLUSTERING_REDUCTION * ON_DEMAND_PRICE_PER_TB;

        if (clusterSavings > 0.01) {
          recommendations.push("Add clustering to reduce query costs by scanning 25% less data (" + Math.round(queriesPerMonth) + " queries/month) - Calculated savings: $" + clusterSavings.toFixed(2) + "/month [HIGH CONFIDENCE]. See [Introduction to clustered tables](https://cloud.google.com/bigquery/docs/clustered-tables)");
          savingsBreakdown.push({
            type: "Clustering",
            amount: clusterSavings,
            confidence: "high"
          });
          potentialSavings += clusterSavings;
        }
      } else {
        // Phase 1: Without query stats
        recommendations.push("Add clustering to improve query performance for large table (" + totalGB.toFixed(2) + " GB) - savings depend on query patterns. See [Introduction to clustered tables](https://cloud.google.com/bigquery/docs/clustered-tables)");
        confidenceLevel = "low";
      }
    } else {
      if (debug) {
        console.log("Table " + table.id + " is already clustered or too small (" + totalGB.toFixed(2) + " GB)");
      }
    }

    // 4. Expiration policy recommendations
    if (!table.expirationTime && totalGB > 0.1) { // Tables over 100MB
      // Phase 1: Calculate potential future savings based on growth rate
      if (tableDetails.creationTime) {
        var creationTime = parseFloat(tableDetails.creationTime);
        var tableAgeDays = (currentTime - creationTime) / (1000 * 60 * 60 * 24);

        if (tableAgeDays > 30) { // Only estimate for tables older than 30 days
          var growthRatePerDay = totalGB / tableAgeDays;
          var annualGrowthGB = growthRatePerDay * 365;
          var futureAnnualStorageCost = annualGrowthGB * ACTIVE_STORAGE_PRICE;

          if (futureAnnualStorageCost > 1) { // Only recommend if > $1/year
            recommendations.push("Set table expiration policy to prevent unlimited data accumulation (current: " + totalGB.toFixed(2) + " GB, growing ~" + growthRatePerDay.toFixed(3) + " GB/day) - Estimated future annual cost without expiration: $" + futureAnnualStorageCost.toFixed(2) + " [MEDIUM CONFIDENCE]. See [Control Storage costs > Use table expiration for destination tables](https://cloud.google.com/bigquery/docs/best-practices-costs#use_table_expiration_for_destination_tables)");
            if (priority === "low") priority = "medium";
            confidenceLevel = confidenceLevel === "high" ? "medium" : confidenceLevel;
          }
        }
      } else {
        recommendations.push("Set table expiration policy to prevent data accumulation (" + totalGB.toFixed(2) + " GB). See [Control Storage costs > Use table expiration for destination tables](https://cloud.google.com/bigquery/docs/best-practices-costs#use_table_expiration_for_destination_tables)");
        if (priority === "low") priority = "medium";
      }
    }

    // 5. Time travel optimization
    // PHASE 1 FIX: Time travel uses active logical storage pricing, not physical
    if (timeTravelGB > totalGB * 0.5) { // Time travel > 50% of total size
      // Conservative estimate: 30% reduction in time travel storage by optimizing retention settings
      // Time travel data is stored as active logical storage
      var timeTravelSavings = timeTravelGB * TIME_TRAVEL_REDUCTION * ACTIVE_STORAGE_PRICE;
      recommendations.push("Optimize time travel retention (currently " + timeTravelGB.toFixed(2) + " GB) to reduce Active Logical Storage costs by ~$" + timeTravelSavings.toFixed(2) + "/month [MEDIUM CONFIDENCE - assumes 30% reduction]. See [Control storage costs > Reduce the time travel window](https://cloud.google.com/bigquery/docs/best-practices-costs#reduce_the_time_travel_window)");
      savingsBreakdown.push({
        type: "Time Travel Optimization",
        amount: timeTravelSavings,
        confidence: "medium"
      });
      potentialSavings += timeTravelSavings;
      confidenceLevel = confidenceLevel === "high" ? "medium" : confidenceLevel;
    } else {
      if (debug) {
        console.log("Table " + table.id + " has acceptable time travel storage (" + timeTravelGB.toFixed(2) + " GB)");
      }
    }

    // 6. Large table analysis
    if (totalGB > 100) { // Very large tables
      recommendations.push("Review large table (" + totalGB.toFixed(2) + " GB) for archiving or partitioning strategies");
      if (priority === "low") priority = "high";
    } else {
      if (debug) {
        console.log("Table " + table.id + " is not a very large table (" + totalGB.toFixed(2) + " GB)");
      }
    }

    // 7. View optimization - check for SELECT * in views
    if (table.type && table.type.toUpperCase() === "VIEW" && tableDetails.view && tableDetails.view.query) {
      var viewQuery = tableDetails.view.query.toUpperCase();
      var selectStarRegex = new RegExp("(SELECT)(\\s+)(\\*)");
      var selectStarExceptRegex = new RegExp('(SELECT)(\\s+)(\\*{1})(\\s+)(EXCEPT)');

      if (selectStarRegex.test(viewQuery) && !selectStarExceptRegex.test(viewQuery)) {
        // Phase 1: Estimate savings based on schema and table size
        if (tableDetails.schema && tableDetails.schema.fields && tableDetails.schema.fields.length > 5) {
          var totalColumns = tableDetails.schema.fields.length;
          var estimatedUnusedColumns = Math.floor(totalColumns * VIEW_COLUMN_REDUCTION);

          // Phase 2: With query stats (high confidence)
          if (queryStats.hasData && queriesPerMonth > 0) {
            var avgBytesScannedGB = queryStats.avgBytesProcessed / (1024 * 1024 * 1024);
            var columnReductionSavings = (avgBytesScannedGB / 1024) * queriesPerMonth * VIEW_COLUMN_REDUCTION * ON_DEMAND_PRICE_PER_TB;

            recommendations.push("View uses `SELECT *` preventing column pruning (" + totalColumns + " columns, ~" + estimatedUnusedColumns + " typically unused, " + Math.round(queriesPerMonth) + " queries/month) - Calculated savings: $" + columnReductionSavings.toFixed(2) + "/month [HIGH CONFIDENCE]. Use explicit column list or EXCEPT clause. See [Reduce data processed > Avoid SELECT *](https://cloud.google.com/bigquery/docs/best-practices-performance-compute#avoid_select_)");
            savingsBreakdown.push({
              type: "View Optimization",
              amount: columnReductionSavings,
              confidence: "high"
            });
            potentialSavings += columnReductionSavings;
            if (priority === "low") priority = "medium";
          } else {
            // Phase 1: Without query stats - don't estimate compute savings without data
            recommendations.push("View uses `SELECT *` preventing column pruning (" + totalColumns + " columns, ~" + estimatedUnusedColumns + " typically unused) - potential savings depend on query patterns" + queryAnalysisTip + ". Use explicit column list or EXCEPT clause. See [Reduce data processed > Avoid SELECT *](https://cloud.google.com/bigquery/docs/best-practices-performance-compute#avoid_select_)");
            confidenceLevel = "low";
            if (priority === "low") priority = "medium";
          }
        } else {
          recommendations.push("View uses `SELECT *` preventing column pruning - consider explicitly selecting only needed columns or using EXCEPT clause. See [Reduce data processed > Avoid SELECT *](https://cloud.google.com/bigquery/docs/best-practices-performance-compute#avoid_select_)");
          if (priority === "low") priority = "medium";
        }
      }
    }

    // 8. Partition expiration policy for partitioned tables
    if ((table.timePartitioning || table.rangePartitioning) && tableDetails.timePartitioningDetails) {
      var hasExpiration = false;
      if (tableDetails.timePartitioningDetails && tableDetails.timePartitioningDetails.expirationMs) {
        hasExpiration = true;
      }
      if (!hasExpiration && totalGB > 1) { // Only recommend for tables > 1GB
        recommendations.push("Partitioned table lacks partition expiration policy - consider setting time_partitioning_expiration to automatically remove old partitions and reduce storage costs. See [Optimize storage for query performance > Use the table and partition expiration settings](https://cloud.google.com/bigquery/docs/best-practices-storage#use-expiration-settings)");
        if (priority === "low") priority = "medium";
      }
    }

    // 9. Date-sharded table detection and oversharding
    // Note: This is handled after the main loop to analyze across all tables in a dataset

    // 10. Check for missing primary key and foreign key constraints
    if (tableDetails.schema && tableDetails.schema.fields && totalGB > 1 && table.type === "TABLE") {
      var fields = tableDetails.schema.fields;
      var hasPrimaryKey = false;
      var potentialKeyColumns = [];

      // Check if primary or foreign key constraints are defined
      for (var f = 0; f < fields.length; f++) {
        var field = fields[f];

        // Check for primary key constraint
        if (field.policyTags && field.policyTags.primaryKey) {
          hasPrimaryKey = true;
        }

        // Identify potential key columns by name patterns (id, _id, key, *_key, *_id)
        var fieldName = field.name.toLowerCase();
        if (fieldName === 'id' ||
            endsWith(fieldName, '_id') ||
            fieldName === 'key' ||
            endsWith(fieldName, '_key') ||
            fieldName === 'pk' ||
            endsWith(fieldName, '_pk')) {
          potentialKeyColumns.push(field.name);
        }
      }

      // Recommend adding constraints if potential key columns found but no constraints defined
      if (!hasPrimaryKey && potentialKeyColumns.length > 0 && totalGB > 10) {
        recommendations.push("Table contains potential key columns (" + potentialKeyColumns.join(", ") + ") but no primary/foreign key constraints defined - consider adding constraints to help query optimizer improve performance. See [Optimize query operations > Specify primary key and foreign key constraints](https://cloud.google.com/bigquery/docs/best-practices-performance-compute#specify_primary_key_and_foreign_key_constraints)");
      }
    }

    // Cap potential savings at current cost to prevent unrealistic estimates
    // This can happen with low-confidence estimates on small tables
    if (potentialSavings > currentCost && currentCost > 0) {
      if (debug) {
        console.log("Capping potential savings for table " + table.id + " from $" + potentialSavings.toFixed(2) + " to current cost $" + currentCost.toFixed(2));
      }
      potentialSavings = currentCost;
    }

    // Only include tables with recommendations
    // We allow $0 savings because some recommendations are operational improvements (partitioning, clustering)
    // that provide value even without measurable cost savings (requires query data to quantify)
    if (recommendations.length > 0 && potentialSavings >= param_min_savings) {
      table.recommendations = recommendations.join("\n\n");
      table.potentialSavings = potentialSavings;
      table.currentCost = currentCost;
      table.totalGB = totalGB;
      table.activeGB = activeGB;
      table.longTermGB = longTermGB;
      table.physicalGB = physicalGB;
      table.timeTravelGB = timeTravelGB;
      table.numRows = tableDetails.numRows || "0";
      table.numPartitions = tableDetails.numPartitions || "0";
      table.priority = priority;
      table.location = table.location || "Unknown";
      table.tableDetails = tableDetails;
      table.confidenceLevel = confidenceLevel;
      table.savingsBreakdown = savingsBreakdown;
      table.queryCount = queryStats.hasData ? Math.round(queriesPerMonth) : 0;
      table.hasQueryData = queryStats.hasData ? "Yes" : "No";

      result.push(table);
    } else {
      if (debug) {
        console.log("No significant recommendations or savings for table " + table.id);
      }
    }
  }

  // 9 & 10. Detect date-sharded tables and table oversharding
  // Group tables by potential base name to detect sharding patterns
  var tablesByDataset = {};

  for (var i = 0; i < ds_google_bigquery_tables.length; i++) {
    var table = ds_google_bigquery_tables[i];
    var datasetKey = table.projectId + ":" + table.datasetId;

    if (!tablesByDataset[datasetKey]) {
      tablesByDataset[datasetKey] = [];
    }
    tablesByDataset[datasetKey].push(table);
  }

  // Check each dataset for sharding patterns
  for (var datasetKey in tablesByDataset) {
    var tablesInDataset = tablesByDataset[datasetKey];
    var baseNameGroups = {};

    // Pattern to detect date suffixes: YYYYMMDD, YYYY_MM_DD, YYYYMM, YYYY_MM
    var dateSuffixPatterns = [
      /^(.+?)_?(\d{8})$/,           // table_20250101 or table20250101
      /^(.+?)_(\d{4})_(\d{2})_(\d{2})$/,  // table_2025_01_01
      /^(.+?)_?(\d{6})$/,           // table_202501 or table202501
      /^(.+?)_(\d{4})_(\d{2})$/,    // table_2025_01
      /^(.+?)_(\d{4})(\d{2})(\d{2})$/ // table20250101 (no separator)
    ];

    // Group tables by base name
    for (var i = 0; i < tablesInDataset.length; i++) {
      var table = tablesInDataset[i];
      var tableName = table.tableId;
      var baseName = tableName;
      var isDateSharded = false;

      // Try each date pattern
      for (var p = 0; p < dateSuffixPatterns.length; p++) {
        var match = tableName.match(dateSuffixPatterns[p]);
        if (match) {
          baseName = match[1];
          isDateSharded = true;
          break;
        }
      }

      // Also check for generic numeric suffixes that might indicate sharding
      if (!isDateSharded) {
        var numericSuffixMatch = tableName.match(/^(.+?)_(\d+)$/);
        if (numericSuffixMatch) {
          baseName = numericSuffixMatch[1];
        }
      }

      if (!baseNameGroups[baseName]) {
        baseNameGroups[baseName] = {
          tables: [],
          isDateSharded: false,
          hasPartitionedVersion: false
        };
      }

      baseNameGroups[baseName].tables.push(table);
      if (isDateSharded) {
        baseNameGroups[baseName].isDateSharded = true;
      }

      // Check if a partitioned version exists
      if (table.timePartitioning || table.rangePartitioning) {
        baseNameGroups[baseName].hasPartitionedVersion = true;
      }
    }

    // Analyze each base name group
    for (var baseName in baseNameGroups) {
      var group = baseNameGroups[baseName];
      var shardCount = group.tables.length;

      // Skip if only one table (not sharded)
      if (shardCount <= 1) continue;

      // Find matching table details to get total size
      var totalGroupSize = 0;
      for (var i = 0; i < group.tables.length; i++) {
        var table = group.tables[i];
        for (var j = 0; j < ds_google_bigquery_tables_details.length; j++) {
          if (ds_google_bigquery_tables_details[j].iter_item_id === table.id) {
            var bytes = parseFloat(ds_google_bigquery_tables_details[j].numBytes || 0);
            totalGroupSize += bytes / (1024 * 1024 * 1024); // Convert to GB
            break;
          }
        }
      }

      // Date-sharded table recommendation (3+ tables with date pattern)
      if (group.isDateSharded && shardCount >= 3 && !group.hasPartitionedVersion) {
        // Add recommendation to the first table in the group (as representative)
        var representativeTable = group.tables[0];
        var existingIndex = -1;

        for (var i = 0; i < result.length; i++) {
          if (result[i].id === representativeTable.id) {
            existingIndex = i;
            break;
          }
        }

        // Phase 2: Calculate savings with query stats
        var shardingSavings = 0;
        var shardingConfidence = "low";
        var totalQueriesPerMonth = 0;
        var totalSlotMs = 0;

        // Check if we have query stats for any tables in this shard group
        for (var i = 0; i < group.tables.length; i++) {
          var shardTable = group.tables[i];
          var shardKey = shardTable.projectId + ":" + shardTable.datasetId + ":" + shardTable.tableId;
          var shardStats = queryStatsMap[shardKey];

          if (shardStats && shardStats.hasData) {
            totalQueriesPerMonth += (shardStats.queryCount / param_query_lookback_days) * 30;
            totalSlotMs += shardStats.avgSlotMs * ((shardStats.queryCount / param_query_lookback_days) * 30);
          }
        }

        var shardingRecommendation = "Dataset contains " + shardCount + " date-sharded tables with base name '" + baseName + "' (" + totalGroupSize.toFixed(2) + " GB total) - migrate to a single time-partitioned table for better performance and easier management";

        if (totalQueriesPerMonth > 0) {
          // High confidence calculation with query data
          // Sharding overhead: query planning and metadata checking across multiple tables
          var slotHours = totalSlotMs / (1000 * 60 * 60);
          shardingSavings = slotHours * SHARDING_OVERHEAD * SLOT_PRICE_PER_HOUR;
          shardingConfidence = "high";
          shardingRecommendation += " - Calculated query performance savings: $" + shardingSavings.toFixed(2) + "/month [HIGH CONFIDENCE - based on " + Math.round(totalQueriesPerMonth) + " queries/month]";
        } else {
          // No query data - don't estimate compute savings
          shardingSavings = 0;
          shardingConfidence = "low";
          shardingRecommendation += " - potential savings depend on query patterns" + queryAnalysisTip;
        }

        shardingRecommendation += ". See [Reduce data processed > Avoid oversharding tables](https://cloud.google.com/bigquery/docs/best-practices-performance-compute#avoid_oversharding_tables)";

        if (existingIndex >= 0) {
          // Table already in results, add recommendation
          result[existingIndex].recommendations += "; " + shardingRecommendation;
          result[existingIndex].potentialSavings += shardingSavings;
          if (shardingSavings > 0) {
            result[existingIndex].savingsBreakdown.push({
              type: "Date-Sharded Migration",
              amount: shardingSavings,
              confidence: shardingConfidence
            });
          }
          if (result[existingIndex].confidenceLevel === "high" && shardingConfidence === "low") {
            result[existingIndex].confidenceLevel = "medium";
          }
          if (result[existingIndex].priority === "low") result[existingIndex].priority = "high";
        } else {
          // Create new entry for this sharding issue
          var newEntry = JSON.parse(JSON.stringify(representativeTable));
          newEntry.recommendations = shardingRecommendation;
          newEntry.potentialSavings = shardingSavings;
          newEntry.currentCost = 0;
          newEntry.priority = "high";
          newEntry.shardCount = shardCount;
          newEntry.totalGroupSizeGB = totalGroupSize;
          newEntry.totalGB = totalGroupSize;
          newEntry.activeGB = 0;
          newEntry.longTermGB = 0;
          newEntry.physicalGB = 0;
          newEntry.timeTravelGB = 0;
          newEntry.numRows = "0";
          newEntry.numPartitions = "0";
          newEntry.location = representativeTable.location || "Unknown";
          newEntry.confidenceLevel = shardingConfidence;
          newEntry.savingsBreakdown = shardingSavings > 0 ? [{
            type: "Date-Sharded Migration",
            amount: shardingSavings,
            confidence: shardingConfidence
          }] : [];
          newEntry.queryCount = Math.round(totalQueriesPerMonth);
          newEntry.hasQueryData = totalQueriesPerMonth > 0 ? "Yes" : "No";
          result.push(newEntry);
        }
      }

      // Oversharding recommendation (10+ tables with same base name)
      if (shardCount >= 10 && !group.hasPartitionedVersion) {
        var representativeTable = group.tables[0];
        var existingIndex = -1;

        for (var i = 0; i < result.length; i++) {
          if (result[i].id === representativeTable.id) {
            existingIndex = i;
            break;
          }
        }

        var overshardingMsg = "Dataset contains " + shardCount + " tables with base name '" + baseName + "' (" + totalGroupSize.toFixed(2) + " GB total) - excessive table sharding detected. Consider consolidating into a single partitioned table to improve query performance and reduce metadata overhead. See [Reduce data processed > Avoid oversharding tables](https://cloud.google.com/bigquery/docs/best-practices-performance-compute#avoid_oversharding_tables)";

        if (existingIndex >= 0) {
          // Check if we already added date-sharded recommendation
          if (result[existingIndex].recommendations.indexOf("date-sharded tables") === -1) {
            result[existingIndex].recommendations += "; " + overshardingMsg;
          }
          result[existingIndex].priority = "high";
        } else {
          // Create new entry
          var newEntry = JSON.parse(JSON.stringify(representativeTable));
          newEntry.recommendations = overshardingMsg;
          newEntry.potentialSavings = 0;
          newEntry.currentCost = 0;
          newEntry.priority = "high";
          newEntry.shardCount = shardCount;
          newEntry.totalGroupSizeGB = totalGroupSize;
          newEntry.totalGB = totalGroupSize;
          newEntry.activeGB = 0;
          newEntry.longTermGB = 0;
          newEntry.physicalGB = 0;
          newEntry.timeTravelGB = 0;
          newEntry.numRows = "0";
          newEntry.numPartitions = "0";
          newEntry.location = representativeTable.location || "Unknown";
          result.push(newEntry);
        }
      }
    }
  }

  // Sort by potential savings (highest first)
  result.sort(function(a, b) {
    return b.potentialSavings - a.potentialSavings;
  });
EOS
end

###############################################################################
# Policy
###############################################################################

policy "pol_bigquery_storage_optimization" do
#   validate $ds_google_bigquery_datasets do
#     summary_template "Google BigQuery Storage Optimization: {{ len data }} Google BigQuery Datasets Found"
#     detail_template <<-'EOS'
# The policy found {{ len data }} Google BigQuery Datasets.
#     EOS
#     check eq(size(data), 0)
#     # escalate $esc_email
#     export do
#       resource_level true
#       field "id" do
#         label "Resource ID"
#       end
#       field "datasetId" do
#         label "Dataset ID"
#       end
#       field "friendlyName" do
#         label "Dataset Name"
#         path "friendlyName"
#       end
#       field "region" do
#         label "Location"
#         path "location"
#       end
#       field "vendor_account" do
#         label "Project ID"
#         path "projectId"
#       end
#       field "vendor_account_name" do
#         label "Project Name"
#         path "projectName"
#       end
#       field "projectNumber" do
#         label "Project Number"
#         path "projectNumber"
#       end
#     end
#   end
#   validate $ds_google_bigquery_tables do
#     summary_template "Google BigQuery Storage Optimization: {{ len data }} Google BigQuery Tables Found"
#     detail_template <<-'EOS'
# The policy found {{ len data }} Google BigQuery Tables.
#     EOS
#     check eq(size(data), 0)
#     # escalate $esc_email
#   end
  validate $ds_analyze_tables do
    summary_template "Google BigQuery Optimization: {{ len data }} Tables with Cost-Saving Recommendations"
    detail_template <<-EOS
## BigQuery Storage and Compute Optimization Report

This report identified **{{ len data }}** Google BigQuery table(s) with storage and performance optimization opportunities.

{{ if eq parameters.param_enable_query_analysis "Enable Query Analysis" }}
### Query Analysis Period

Query patterns were analyzed over the past {{ parameters.param_query_lookback_days }} days to calculate accurate savings estimates.

{{ end }}
### Detailed Recommendations

{{ if eq (len data) 0 }}
No optimization recommendations were found that meet the minimum savings threshold.
{{ else }}
{{ range data }}
---

#### **{{.tableId}}** (Priority: {{.priority}}, Confidence: {{.confidenceLevel}})
**Project**: {{.projectId}}
**Dataset**: {{.datasetId}}
**Location**: {{.location}}
{{ if eq .hasQueryData "Yes" }}**Query Activity**: {{ .queryCount }} queries/month analyzed{{ end }}

**Storage Details**:
- Total Size: {{ (printf "%.2f" .totalGB) }} GB
- Active Storage: {{ (printf "%.2f" .activeGB) }} GB
- Long-term Storage: {{ (printf "%.2f" .longTermGB) }} GB
- Physical Storage: {{ (printf "%.2f" .physicalGB) }} GB
- Time Travel Storage: {{ (printf "%.2f" .timeTravelGB) }} GB
- Rows: {{ .numRows }}
- Partitions: {{ .numPartitions }}

**Current Monthly Cost**: ${{ (printf "%.2f" .currentCost) }}
{{ if gt .potentialSavings 0.0 }}
**Potential Monthly Savings**: ${{ (printf "%.2f" .potentialSavings) }}
{{ end }}
**Recommendations**:

{{ .recommendations }}

**Table Configuration**:
- Type: {{ .type }}
- Partitioning: {{ if .timePartitioning }}Yes{{ else }}No{{ end }}
- Clustering: {{ if .clustering }}Yes{{ else }}No{{ end }}
- Expiration: {{ if .expirationTime }}{{ .expirationTime }}{{ else }}None{{ end }}

{{ end }}
{{ end }}

---

### Next Steps

1. **High Confidence Recommendations**: These are based on actual query data and can be implemented with confidence
2. **Medium Confidence Recommendations**: Review these recommendations in the context of your workload
3. **Low Confidence Recommendations**: Consider enabling query statistics collection for more accurate estimates

### Optimization Categories

This policy analyzes 11 best practices from Google Cloud documentation:

- **Long-term Storage Migration**: Move infrequently accessed data to cheaper long-term storage
- **Partitioning Improvements**: Add partitioning to large tables for better performance and cost efficiency
- **Clustering Optimization**: Implement clustering to reduce query costs
- **Table Expiration Policies**: Set table expiration to prevent unnecessary data accumulation
- **Time Travel Optimization**: Reduce time travel retention for cost savings
- **Large Table Review**: Flag very large tables for manual review and optimization
- **View Optimization**: Identify views using `SELECT *` which prevents column pruning and increases query costs
- **Partition Expiration Settings**: Auto-delete old partitions to reduce storage costs
- **Date-Sharded Table Detection**: Migrate date-suffixed tables to time-partitioned tables
- **Table Oversharding Detection**: Consolidate excessive table shards into partitioned tables
- **Primary/Foreign Key Constraints**: Add missing constraints to help query optimizer improve performance

### Savings Calculation Methodology

**Conservative Reduction Factors Used:**
- Partitioning: 70% reduction in bytes scanned (conservative industry estimate)
- Clustering: 25% reduction in bytes scanned (conservative industry estimate)
- View column pruning: 35% of columns typically unused
- Time travel optimization: 30% storage reduction with optimized retention
- Date-sharding overhead: 15% query performance improvement

**Confidence Levels:**
- **HIGH CONFIDENCE**: Calculations based on actual query statistics from INFORMATION_SCHEMA.JOBS
- **MEDIUM CONFIDENCE**: Calculations based on table metadata and conservative industry estimates
- **LOW CONFIDENCE**: Estimates based on assumptions about query patterns (no query data available)

**Pricing Reference:** https://cloud.google.com/bigquery/pricing
- Active Storage: $0.02/GB/month
- Long-term Storage: $0.01/GB/month
- Analysis (on-demand): $6.25/TB processed

### Additional Resources

- [BigQuery Best Practices - Performance](https://cloud.google.com/bigquery/docs/best-practices-performance-compute)
- [BigQuery Best Practices - Storage](https://cloud.google.com/bigquery/docs/best-practices-storage)
- [BigQuery Pricing Documentation](https://cloud.google.com/bigquery/pricing)

EOS
    check logic_or($ds_parent_policy_terminated,    eq(size(data), 0)    )
    escalate $esc_email
    export do
      resource_level true
      field "id" do
        label "Resource ID"
      end
      field "tableId" do
        label "Table ID"
        path "tableId"
      end
      field "datasetId" do
        label "Dataset ID"
        path "datasetId"
      end
      field "projectId" do
        label "Project ID"
        path "projectId"
      end
      field "projectName" do
        label "Project Name"
        path "projectName"
      end
      field "location" do
        label "Location"
        path "location"
      end
      field "priority" do
        label "Priority"
        path "priority"
      end
      field "confidenceLevel" do
        label "Confidence Level"
        path "confidenceLevel"
      end
      field "hasQueryData" do
        label "Has Query Data"
        path "hasQueryData"
      end
      field "queryCount" do
        label "Monthly Queries"
        path "queryCount"
      end
      field "totalGB" do
        label "Total Size (GB)"
        path "totalGB"
      end
      field "activeGB" do
        label "Active Storage (GB)"
        path "activeGB"
      end
      field "longTermGB" do
        label "Long-term Storage (GB)"
        path "longTermGB"
      end
      field "currentCost" do
        label "Current Monthly Cost ($)"
        path "currentCost"
      end
      field "savings" do
        label "Potential Monthly Savings ($)"
        path "potentialSavings"
      end
      field "recommendations" do
        label "Optimization Recommendations"
        path "recommendations"
      end
      field "numRows" do
        label "Row Count"
        path "numRows"
      end
      field "numPartitions" do
        label "Partition Count"
        path "numPartitions"
      end
    end
  end

#   validate $ds_google_bigquery_jobs do
#     summary_template "Google BigQuery Storage Optimization: {{ len data }} Google BigQuery Jobs Found"
#     detail_template <<-'EOS'
# The policy found {{ len data }} Google BigQuery Jobs.
#     EOS
#     check eq(size(data), 0)
#     escalate $esc_email
#   end
end

###############################################################################
# Escalations
###############################################################################

escalation "esc_email" do
  automatic true
  label "Send Email"
  description "Send incident email"
  email $param_email
end

###############################################################################
# Cloud Workflow
###############################################################################



###############################################################################
# Meta Policy [alpha]
# Not intended to be modified or used by policy developers
###############################################################################

# If the meta_parent_policy_id is not set it will evaluate to an empty string and we will look for the policy itself,
# if it is set we will look for the parent policy.
datasource "ds_get_parent_policy" do
  request do
    auth $auth_flexera
    host val($ds_flexera_api_hosts, "flexera")
    path join(["/policy/v1/orgs/", rs_org_id, "/projects/", rs_project_id, "/applied-policies/", switch(ne(meta_parent_policy_id, ""), meta_parent_policy_id, policy_id) ])
    ignore_status [404]
  end
  result do
    encoding "json"
    field "id", jmes_path(response, "id")
  end
end

# If the policy was applied by a meta_parent_policy we confirm it exists if it doesn't we confirm we are deleting
# This information is used in two places:
# - determining whether or not we make a delete call
# - determining if we should create an incident (we don't want to create an incident on the run where we terminate)
datasource "ds_parent_policy_terminated" do
  run_script $js_parent_policy_terminated, $ds_get_parent_policy, meta_parent_policy_id
end

script "js_parent_policy_terminated", type: "javascript" do
  parameters "ds_get_parent_policy", "meta_parent_policy_id"
  result "result"
  code <<-'EOS'
  result = meta_parent_policy_id != "" && ds_get_parent_policy["id"] == undefined
EOS
end

# Two potentials ways to set this up:
# - this way and make a unneeded 'get' request when not deleting
# - make the delete request an interate and have it iterate over an empty array when not deleting and an array with one item when deleting
datasource "ds_terminate_self" do
  request do
    run_script $js_make_terminate_request, $ds_parent_policy_terminated, $ds_flexera_api_hosts, policy_id, rs_org_id, rs_project_id
  end
end

script "js_make_terminate_request", type: "javascript" do
  parameters "ds_parent_policy_terminated", "ds_flexera_api_hosts", "policy_id", "rs_org_id", "rs_project_id"
  result "request"
  code <<-EOS
  var request = {
    auth: "auth_flexera",
    host: ds_flexera_api_hosts["flexera"],
    path: [ "/policy/v1/orgs/", rs_org_id, "/projects/", rs_project_id, "/applied-policies", policy_id ? "/"+policy_id : "" ].join(''),
    verb: ds_parent_policy_terminated ? "DELETE" : "GET"
  }
EOS
end

# This is just a way to have the check delete request connect to the farthest leaf from policy.
# We want the delete check to the first thing the policy does to avoid the policy erroring before it can decide whether or not it needs to self terminate
# Example a customer deletes a credential and then terminates the parent policy. We still want the children to self terminate
# The only way I could see this not happening is if the user who applied the parent_meta_policy was offboarded or lost policy access, the policies who are impersonating the user
# would not have access to self-terminate
# It may be useful for the backend to enable a mass terminate at some point for all meta_child_policies associated with an id.
datasource "ds_is_deleted" do
  run_script $js_is_deleted, $ds_terminate_self
end

script "js_is_deleted", type: "javascript" do
  parameters "ds_terminate_self"
  result "result"
  code 'result = { path: "/"}'
end
