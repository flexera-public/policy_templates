name "Dynamic Dashboards"
rs_pt_ver 20180301
type "policy"
short_description "Creates dynamic dashboards based on cost data aggregated by user-specified dimensions over the previous 12 months. See the [README](https://github.com/flexera-public/policy_templates/tree/master/operational/flexera/cco/dynamic_dashboards/) and [docs.flexera.com/flexera/EN/Automation](https://docs.flexera.com/flexera/EN/Automation/AutomationGS.htm) to learn more."
long_description ""
doc_link "https://github.com/flexera-public/policy_templates/tree/master/operational/flexera/cco/dynamic_dashboards/"
category "Operational"
severity "low"
default_frequency "daily"
info(
  version: "0.1.0",
  provider: "Flexera",
  service: "Cloud Cost Optimization",
  policy_set: "Cloud Cost Optimization",
  hide_skip_approvals: "true"
)

###############################################################################
# Parameters
###############################################################################

parameter "param_cost_metric" do
  type "string"
  category "Dashboard Settings"
  label "Cost Metric"
  description "Select the cost metric for your report"
  allowed_values ["Amortized", "Unamortized"]
  default "Amortized"
end

parameter "param_dashboard_prefix" do
  type "string"
  category "Dashboard Settings"
  label "Dashboard Prefix"
  description "Prefix to use for dynamic dashboard names.  Will have a space appended to end if not included."
  default "Dynamic Dashboard for"
end

parameter "param_dashboard_group_dimension" do
  type "string"
  category "Dashboard Settings"
  label "Dashboard Dimension"
  description "The dimension to aggregate costs by for dashboard creation"
  default "Cloud Vendor"
end

parameter "param_dashboard_group_dimension_filter" do
  type "list"
  category "Dashboard Settings"
  label "Filter Dashboard Dimension Value List"
  description "List of values to create a dashboard for the selected filter dimension. Leave blank to include all values."
  default []
end

parameter "param_dashboard_group_dimension_filter_allow_or_deny" do
  type "string"
  category "Dashboard Settings"
  label "Allow/Deny Filter Dashboard Dimension Value List"
  description "Allow or Deny entered Filter Dashboard Dimension Value List. See the README for more details"
  allowed_values "Allow", "Deny"
  default "Allow"
end

parameter "param_widget_dimension" do
  type "string"
  category "Dashboard Settings"
  label "Widget Dimension"
  description "The dimension to aggregate costs by for widget creation"
  default "Service"
end

parameter "param_widget_dimension_count" do
  type "number"
  category "Dashboard Settings"
  label "Widget Count"
  description "Number of top widgets to display in each dashboard"
  min_value 1
  max_value 20
  default 10
end

parameter "param_widget_dimension_filter" do
  type "list"
  category "Dashboard Settings"
  label "Filter Widget Dimension Value List"
  description "List of values to create a widget for the selected filter dimension. Leave blank to include all values."
  default []
end

parameter "param_widget_dimension_filter_allow_or_deny" do
  type "string"
  category "Dashboard Settings"
  label "Allow/Deny Filter Widget Dimension Value List"
  description "Allow or Deny entered Filter Widget Dimension Value List. See the README for more details"
  allowed_values "Allow", "Deny"
  default "Allow"
end

parameter "param_include_marketplace_charges" do
  type "string"
  category "Dashboard Settings"
  label "Allow/Deny Include Marketplace Charges"
  description "Allow or Deny inclusion of marketplace charges in the widget. See the README for more details"
  allowed_values "Include Marketplace Charges", "Exclude Marketplace Charges"
  default "Exclude Marketplace Charges"
end

###############################################################################
# Authentication
###############################################################################

credentials "auth_flexera" do
  schemes "oauth2"
  label "flexera"
  description "Select FlexeraOne OAuth2 credential."
  tags "provider=flexera"
end

###############################################################################
# Datasources & Scripts
###############################################################################

datasource "ds_dimensions" do
  request do
    auth $auth_flexera
    host rs_optima_host
    path join(["/bill-analysis/orgs/", rs_org_id, "/costs/dimensions"])
    header "Api-Version", "1.0"
    header "User-Agent", "RS Policies"
  end
  result do
    encoding "json"
    collect jmes_path(response, "dimensions") do
      field "id", jmes_path(col_item, "id")
      field "name", jmes_path(col_item, "name")
      field "type", jmes_path(col_item, "type")
    end
  end
end

# Immutable data tables
datasource "ds_data_tables" do
  run_script $js_data_tables, $ds_dimensions
end

script "js_data_tables", type: "javascript" do
  parameters "ds_dimensions"
  result "result"
  code <<-EOS
  result = {
    cost_metrics: {
      "Unamortized": "cost_nonamortized_unblended_adj",
      "Amortized": "cost_amortized_unblended_adj",
      "Unamortized Unblended": "cost_nonamortized_unblended_adj",
      "Amortized Unblended": "cost_amortized_unblended_adj",
      "Unamortized Blended": "cost_nonamortized_blended_adj",
      "Amortized Blended": "cost_amortized_blended_adj"
    },
    dimensions: {}
  }
  _.each(ds_dimensions, function(d) {
    result.dimensions[d.name] = d.id;
  })
EOS
end

datasource "ds_billing_centers" do
  request do
    auth $auth_flexera
    host rs_optima_host
    path join(["/analytics/orgs/", rs_org_id, "/billing_centers"])
    query "view", "allocation_table"
    header "Api-Version", "1.0"
    header "User-Agent", "RS Policies"
    ignore_status [403]
  end
  result do
    encoding "json"
    collect jmes_path(response, "[*]") do
      field "href", jmes_path(col_item, "href")
      field "id", jmes_path(col_item, "id")
      field "name", jmes_path(col_item, "name")
      field "parent_id", jmes_path(col_item, "parent_id")
    end
  end
end

# Gather top level billing center IDs for when we pull cost data
datasource "ds_top_level_bcs" do
  run_script $js_top_level_bcs, $ds_billing_centers
end

script "js_top_level_bcs", type: "javascript" do
  parameters "ds_billing_centers"
  result "result"
  code <<-EOS
  filtered_bcs = _.filter(ds_billing_centers, function(bc) {
    return bc['parent_id'] == null || bc['parent_id'] == undefined
  })

  result = _.compact(_.pluck(filtered_bcs, 'id'))
EOS
end

# Calculate date range for previous 12 months
datasource "ds_date_range" do
  run_script $js_date_range
end

script "js_date_range", type: "javascript" do
  result "result"
  code <<-EOS
  function getFormattedDate(date) {
    var year = date.getFullYear();
    var month = (1 + date.getMonth()).toString();
    month = month.length > 1 ? month : '0' + month;
    return year + '-' + month;
  }

  var now = new Date();
  var end_at = getFormattedDate(now);

  // Go back 12 months
  var start_date = new Date(now.getFullYear(), now.getMonth() - 12, 1);
  var start_at = getFormattedDate(start_date);

  result = {
    start_at: start_at,
    end_at: end_at
  }
EOS
end

# Process cost response data
datasource "ds_cost_response" do
  request do
    run_script $js_cost_response, $ds_top_level_bcs, $ds_data_tables, $ds_date_range, $param_dashboard_group_dimension, $param_widget_dimension, $param_cost_metric, $param_dashboard_group_dimension_filter, $param_dashboard_group_dimension_filter_allow_or_deny, $param_widget_dimension, $param_widget_dimension_filter, $param_widget_dimension_filter_allow_or_deny, $param_include_marketplace_charges, rs_optima_host, rs_org_id
  end
  result do
    encoding "json"
    collect jmes_path(response, "rows[*]") do
      field "dimensions", jmes_path(col_item, "dimensions")
      field "metrics", jmes_path(col_item, "metrics")
      field "timestamp", jmes_path(col_item, "timestamp")
    end
  end
end

script "js_cost_response", type: "javascript" do
  parameters "ds_top_level_bcs", "ds_data_tables", "ds_date_range", "param_dashboard_group_dimension", "param_widget_dimension", "param_cost_metric", "param_dashboard_group_dimension_filter", "param_dashboard_group_dimension_filter_allow_or_deny", "param_widget_dimension", "param_widget_dimension_filter", "param_widget_dimension_filter_allow_or_deny", "param_include_marketplace_charges", "rs_optima_host", "rs_org_id"
  result "request"
  code <<-EOS
  var dimension_id = ds_data_tables['dimensions'][param_dashboard_group_dimension];
  var widget_dimension_id = ds_data_tables['dimensions'][param_widget_dimension];
  var cost_metric = ds_data_tables['cost_metrics'][param_cost_metric];

  var body = {
    "billing_center_ids": ds_top_level_bcs,
    "dimensions": [dimension_id, widget_dimension_id],
    "granularity": "month",
    "start_at": ds_date_range["start_at"],
    "end_at": ds_date_range["end_at"],
    "metrics": [cost_metric],
    "summarized": true
  };

  if (param_dashboard_group_dimension_filter.length > 0) {
    var dashboard_filter = {
      "type": "or",
      "expressions": []
    };
    _.each(param_dashboard_group_dimension_filter, function(value) {
      dashboard_filter.expressions.push({
        "type": "equal",
        "dimension": dimension_id,
        "value": value
      });
    });
    if (param_dashboard_group_dimension_filter_allow_or_deny == "Deny") {
      dashboard_filter = {
        "type": "not",
        "expression": dashboard_filter
      };
    }
  }
  if (param_widget_dimension_filter.length > 0) {
    var widget_filter = {
      "type": "or",
      "expressions": []
    };
    _.each(param_widget_dimension_filter, function(value) {
      widget_filter.expressions.push({
        "type": "equal",
        "dimension": ds_data_tables['dimensions'][param_widget_dimension],
        "value": value
      });
    });
    if (param_widget_dimension_filter_allow_or_deny == "Deny") {
      widget_filter = {
        "type": "not",
        "expression": widget_filter
      };
    }
  }
  if (param_include_marketplace_charges == "Exclude Marketplace Charges") {
    var marketplace_filter = {
      "type": "not",
      "expression": {
        "type": "or",
        "expressions": [
          {
            "type": "equal",
            "dimension": "bill_entity",
            "value": "Marketplace"
          },
          {
            "type": "equal",
            "dimension": "bill_entity",
            "value": "AWS Marketplace"
          },
          {
            "type": "equal",
            "dimension": "category",
            "value": "Marketplace"
          }
        ]
      }
    };
  }
  // Check if we have any filters and if we do update filter body for request
  if (typeof dashboard_filter !== 'undefined' || typeof widget_filter !== 'undefined' || typeof marketplace_filter !== 'undefined') {
    body["filter"] = {
      "type": "and",
      "expressions": []
    };
    if (typeof dashboard_filter !== 'undefined' && _.isObject(dashboard_filter)) {
      body["filter"].expressions.push(dashboard_filter);
    }
    if (typeof widget_filter !== 'undefined' && _.isObject(widget_filter)) {
      body["filter"].expressions.push(widget_filter);
    }
    if (typeof marketplace_filter !== 'undefined' && _.isObject(marketplace_filter)) {
      body["filter"].expressions.push(marketplace_filter);
    }
  }

  var request = {
    auth: 'auth_flexera',
    host: rs_optima_host,
    scheme: 'https',
    verb: 'POST',
    path: "/bill-analysis/orgs/" + rs_org_id + "/costs/aggregated",
    headers: {
      "Api-Version": "1.0",
      "User-Agent": "RS Policies",
      "Content-Type": "application/json"
    },
    body: JSON.stringify(body)
  }
EOS
end

# Process cost data to get top services by dimension value
datasource "ds_processed_cost_data" do
  run_script $js_processed_cost_data, $ds_cost_response, $ds_dimensions, $ds_data_tables, $param_widget_dimension_count, $param_cost_metric, $param_dashboard_group_dimension, $param_widget_dimension, $param_dashboard_prefix
end

script "js_processed_cost_data", type: "javascript" do
  parameters "ds_cost_response", "ds_dimensions", "ds_data_tables", "param_widget_dimension_count", "param_cost_metric", "param_dashboard_group_dimension", "param_widget_dimension", "param_dashboard_prefix"
  result "result"
  code <<-EOS
  // Group by dimension value and aggregate costs by service
  var grouped_data = {};

  var dashboard_dimension = _.find(ds_dimensions, function(d) {
    return d.name.toLowerCase() == param_dashboard_group_dimension.toLowerCase() || d.id.toLowerCase() == param_dashboard_group_dimension.toLowerCase();
  });
  var widget_dimension = _.find(ds_dimensions, function(d) {
    return d.name.toLowerCase() == param_widget_dimension.toLowerCase() || d.id.toLowerCase() == param_widget_dimension.toLowerCase();
  });

  _.each(ds_cost_response, function(row) {
    var dimension_value = row.dimensions[dashboard_dimension.id] || "Unknown";
    var widget_value = row.dimensions[widget_dimension.id] || "Unknown";
    var cost = parseFloat(row.metrics[ ds_data_tables['cost_metrics'][param_cost_metric] ]) || 0;

    if (!grouped_data[dimension_value]) {
      grouped_data[dimension_value] = {};
    }

    if (!grouped_data[dimension_value][widget_value]) {
      grouped_data[dimension_value][widget_value] = 0;
    }

    grouped_data[dimension_value][widget_value] += cost;
  });

  // For each dimension value, get top N widget_value
  result = [];

  _.each(grouped_data, function(widget_values, dimension_value) {
    // Convert to array and sort by cost
    var widget_array = _.map(widget_values, function(cost, widget) {
      return { value: widget, cost: cost };
    });

    widget_array = _.sortBy(widget_array, 'cost').reverse();

    // Take top N
    var top_widgets = _.first(widget_array, param_widget_dimension_count);

    result.push({
      dimension: param_dashboard_group_dimension,
      dimension_value: dimension_value,
      top_widgets: top_widgets,
      total_cost: _.reduce(widget_array, function(sum, item) { return sum + item.cost; }, 0)
    });
  });

  // Sort by total cost descending
  result = _.sortBy(result, 'total_cost').reverse();
EOS
end

# Generate dashboard configurations
datasource "ds_dashboard_configs" do
  run_script $js_dashboard_configs, $ds_processed_cost_data, $ds_data_tables, $ds_dimensions, $ds_get_dashboards, $param_dashboard_group_dimension, $param_cost_metric, $param_widget_dimension, $param_widget_dimension_count, $param_dashboard_prefix
end

script "js_dashboard_configs", type: "javascript" do
  parameters "ds_processed_cost_data", "ds_data_tables", "ds_dimensions", "ds_get_dashboards", "param_dashboard_group_dimension", "param_cost_metric", "param_widget_dimension", "param_widget_dimension_count", "param_dashboard_prefix"
  result "result"
  code <<-EOS
  var cost_metric_id = ds_data_tables['cost_metrics'][param_cost_metric];
  var dimension_id = ds_data_tables['dimensions'][param_dashboard_group_dimension];

  var dashboard_dimension = _.find(ds_dimensions, function(d) {
    return d.name.toLowerCase() == param_dashboard_group_dimension.toLowerCase() || d.id.toLowerCase() == param_dashboard_group_dimension.toLowerCase();
  });
  var widget_dimension = _.find(ds_dimensions, function(d) {
    return d.name.toLowerCase() == param_widget_dimension.toLowerCase() || d.id.toLowerCase() == param_widget_dimension.toLowerCase();
  });

  var result = _.map(ds_processed_cost_data, function(data, index) {
    var dimension_value = data.dimension_value;
    var top_widgets = data.top_widgets;

    // Generate unique widget IDs
    var widget1_id = "widget-" + index + "-1";
    var widget2_id = "widget-" + index + "-2";
    var widget3_id = "widget-" + index + "-3";
    var widget4_id = "widget-" + index + "-4";

    // Create filter for the specific dimension value
    var dimension_filter = {};
    dimension_filter[dimension_id] = [{"id": dimension_value}];

    var now = new Date();

    // Generate dashboard configuration based on the example format
    var config = {
      "description": "Top cost for " + param_dashboard_group_dimension + ": " + dimension_value + ". This dashboard was dynamically generated based on the Top " + param_widget_dimension_count + " " + widget_dimension.name + " based on spend.  Generated at: " + now.toISOString(),
      "layouts": {
        "md": [
          {
            "h": 6,
            "i": widget1_id,
            "minH": 4,
            "minW": 6,
            "moved": false,
            "static": false,
            "w": 6,
            "x": 0,
            "y": 0
          },
          {
            "h": 6,
            "i": widget2_id,
            "minH": 4,
            "minW": 6,
            "moved": false,
            "static": false,
            "w": 6,
            "x": 6,
            "y": 0
          },
        ],
        "sm": [
          {
            "h": 6,
            "i": widget1_id,
            "minH": 4,
            "minW": 2,
            "w": 2,
            "x": 0,
            "y": 0
          },
          {
            "h": 6,
            "i": widget2_id,
            "minH": 4,
            "minW": 2,
            "w": 2,
            "x": 0,
            "y": 6 // +6 for new row (row height is 6)
          },
        ]
      },
      "version": 2,
      "widgets": [
        {
          "component": "bar-chart",
          "description": "",
          "filters": [
            {
              "id": "DimensionParam",
              "source": "manual",
              "value": [widget_dimension.id]
            },
            {
              "id": "GroupByParam",
              "source": "inline"
            },
            {
              "id": "CostTypeParam",
              "source": "default"
            },
            {
              "id": "DateRangeParam",
              "source": "default"
            },
            {
              "id": "CalendarPeriodParam",
              "source": "manual",
              "value": "monthly"
            },
            {
              "id": "SelectParam",
              "scope": "global",
              "source": "manual",
              "value": dimension_filter
            }
          ],
          "id": widget1_id,
          "isPercentageBased": "off",
          "metrics": [
            {
              "id": cost_metric_id,
              "name": param_cost_metric,
              "type": "Cost"
            }
          ],
          "name": "Total Costs by " + widget_dimension.name + " - " + dashboard_dimension.name + ": " + dimension_value
        },
        {
          "component": "bar-chart",
          "description": "",
          "filters": [
            {
              "id": "DimensionParam",
              "source": "manual",
              "value": [widget_dimension.id]
            },
            {
              "id": "GroupByParam",
              "source": "inline"
            },
            {
              "id": "CostTypeParam",
              "source": "default"
            },
            {
              "id": "DateRangeParam",
              "source": "default"
            },
            {
              "id": "CalendarPeriodParam",
              "source": "manual",
              "value": "monthly"
            },
            {
              "id": "SelectParam",
              "scope": "global",
              "source": "manual",
              "value": dimension_filter
            }
          ],
          "id": widget2_id,
          "isPercentageBased": "on",
          "metrics": [
            {
              "id": cost_metric_id,
              "name": param_cost_metric,
              "type": "Cost"
            }
          ],
          "name": "% of Total Costs by " + widget_dimension.name + " - " + dashboard_dimension.name + ": " + dimension_value
        },
        // {
        //   "component": "bar-chart",
        //   "description": "",
        //   "filters": [
        //     {
        //       "id": "DimensionParam",
        //       "source": "manual",
        //       "value": ["resource_type"]
        //     },
        //     {
        //       "id": "GroupByParam",
        //       "source": "inline"
        //     },
        //     {
        //       "id": "CostTypeParam",
        //       "source": "default"
        //     },
        //     {
        //       "id": "DateRangeParam",
        //       "source": "default"
        //     },
        //     {
        //       "id": "CalendarPeriodParam",
        //       "source": "manual",
        //       "value": "monthly"
        //     },
        //     {
        //       "id": "SelectParam",
        //       "scope": "global",
        //       "source": "manual",
        //       "value": dimension_filter
        //     }
        //   ],
        //   "id": widget3_id,
        //   "isPercentageBased": "off",
        //   "metrics": [
        //     {
        //       "id": cost_metric_id,
        //       "name": param_cost_metric,
        //       "type": "Cost"
        //     }
        //   ],
        //   "name": "Total Costs by Resource Type - " + dimension_value
        // },
        // {
        //   "component": "bar-chart",
        //   "description": "",
        //   "filters": [
        //     {
        //       "id": "DimensionParam",
        //       "source": "manual",
        //       "value": ["region"]
        //     },
        //     {
        //       "id": "GroupByParam",
        //       "source": "inline"
        //     },
        //     {
        //       "id": "CostTypeParam",
        //       "source": "default"
        //     },
        //     {
        //       "id": "DateRangeParam",
        //       "source": "default"
        //     },
        //     {
        //       "id": "CalendarPeriodParam",
        //       "source": "manual",
        //       "value": "monthly"
        //     },
        //     {
        //       "id": "SelectParam",
        //       "scope": "global",
        //       "source": "manual",
        //       "value": dimension_filter
        //     }
        //   ],
        //   "id": widget4_id,
        //   "isPercentageBased": "on",
        //   "metrics": [
        //     {
        //       "id": cost_metric_id,
        //       "name": param_cost_metric,
        //       "type": "Cost"
        //     }
        //   ],
        //   "name": "% of Total Costs by Region - " + dimension_value
        // }
      ]
    };

    // For each top_widget, add a widget to the dashboard config
    var row_index = 1; // Row 0 is first row which is added above, so start at 1 for second row
    _.each(data.top_widgets, function(widget) {
      var widget_id = "widget-" + widget.value.replace(/\s+/g, "-").toLowerCase();
      var widget_filter = _.clone(dimension_filter);
      widget_filter[widget_dimension.id] = [{ "id": widget.value }]; // Update the filter to include this specific widget value

      var widget_obj = {
        "component": "bar-chart",
        "description": "",
        "filters": [
          {
            "id": "SelectParam",
            "scope": "global",
            "source": "manual",
            "value": widget_filter
          },
          {
            "id": "DimensionParam",
            "source": "manual",
            "value": ["usage_type"]
          },
          {
            "id": "GroupByParam",
            "source": "inline"
          },
          {
            "id": "CostTypeParam",
            "source": "default"
          },
          {
            "id": "DateRangeParam",
            "source": "default"
          },
          {
            "id": "CalendarPeriodParam",
            "source": "manual",
            "value": "monthly"
          }
        ],
        "id": widget_id,
        "isPercentageBased": "off",
        "metrics": [
          {
            "id": cost_metric_id,
            "name": param_cost_metric,
            "type": "Cost"
          }
        ],
        "name": "Total Costs for " + widget_dimension.name + ": " + widget.value + " - " + dashboard_dimension.name + ": " + dimension_value
      };
      config.widgets.push(widget_obj);
      // Add to sm and md layouts
      config.layouts.md.push({
        "h": 6,
        "i": widget_id,
        "minH": 4,
        "minW": 6,
        "moved": false,
        "static": false,
        "w": 6,
        "x": 0, // 0 for left column, 6 for right
        "y": Math.floor(row_index * 6) // Increment row every two widgets
      });
      config.layouts.sm.push({
        "h": 6,
        "i": widget_id,
        "minH": 4,
        "minW": 2,
        "w": 2,
        "x": 0, // 0 for left column, 2 for right
        "y": Math.floor(row_index * 2) // Increment row every two widgets
      });
      // Update name and isPercentageBased based on widget type
      var widget_percent_obj = _.clone(widget_obj);
      widget_percent_obj.isPercentageBased = "on";
      widget_percent_obj.name = "% of " + widget_percent_obj.name;
      widget_percent_obj.id = widget_id + "-percent";
      config.widgets.push(widget_percent_obj);
      config.layouts.md.push({
        "h": 6,
        "i": widget_id + "-percent",
        "minH": 4,
        "minW": 6,
        "moved": false,
        "static": false,
        "w": 6,
        "x": 6, // 0 for left column, 6 for right
        "y": Math.floor(row_index * 6)
      });
      config.layouts.sm.push({
        "h": 6,
        "i": widget_id + "-percent",
        "minH": 4,
        "minW": 2,
        "w": 2,
        "x": 2, // 0 for left column, 2 for right
        "y": Math.floor(row_index * 6)
      });
      row_index += 1; // Increment row index for next widget
    });

    // Last append a table widget which can be used for drilldown
    var table_widget_id = "widget-drilldown-table";
    var table_widget_obj = {
      "name": "Tabular View for Drilldown into " + param_dashboard_group_dimension + ": " + dimension_value,
      "component": "table",
      "description": "",
      "filters": [
        {
          "id": "DimensionParam",
          "source": "inline"
        },
        {
          "id": "GroupByParam",
          "source": "inline"
        },
        {
          "id": "CostTypeParam",
          "source": "default"
        },
        {
          "id": "DateRangeParam",
          "source": "default"
        },
        {
          "id": "CalendarPeriodParam",
          "source": "default"
        },
        {
          "id": "SelectParam",
          "source": "manual",
          "value": dimension_filter
        }
      ],
      "id": "widget-drilldown-table",
      "isPercentageBased": "off",
      "metrics": [
        {
          "id": cost_metric_id,
          "name": param_cost_metric,
          "type": "Cost"
        }
      ]
    };
    config.widgets.push(table_widget_obj);
    config.layouts.md.push({
      "i": table_widget_id,
      "minH": 12,
      "minW": 12,
      "h": 12,
      "w": 12,
      "x": 0, // 0 for left column, 2 for right
      "y": Math.floor(row_index * 6) // rows are 6 high
    });
    config.layouts.sm.push({
      "i": table_widget_id,
      "minH": 12,
      "minW": 2,
      "h": 12,
      "w": 2,
      "x": 0, // 0 for left column, 2 for right
      "y": Math.floor(row_index * 6) // rows are 6 high
    });

    var dashboard_prefix = ""
    if (param_dashboard_prefix && param_dashboard_prefix.trim().length > 0) {
      dashboard_prefix = param_dashboard_prefix.trim() + " ";
    }

    var dashboard_name = dashboard_prefix + param_dashboard_group_dimension + ": " + dimension_value;
    // Check if dashboard already exists
    var existing_dashboard = _.find(ds_get_dashboards, function(d) {
      return d.name == dashboard_name && d.visibility == "public";
    });
    var id = "";
    var verb = "create"; // Default to create
    if (existing_dashboard) {
      // If it exists, update the config
      id = existing_dashboard.id;
      verb = "update"; // Set verb to update
    }

    return {
      name: dashboard_name,
      config: config,
      dimension_name: param_dashboard_group_dimension,
      dimension_value: dimension_value,
      widget_dimension: param_widget_dimension,
      widget_dimension_values: _.pluck(data.top_widgets, 'value').join(", "),
      verb: verb,
      id: id
    };
  });
EOS
end

datasource "ds_dashboards_grouped" do
  # Filter out PUT requests (existing dashboards to update)
  run_script $js_dashboards_grouped, $ds_dashboard_configs, "update"
end

script "js_dashboards_grouped", type: "javascript" do
  parameters "ds_dashboard_configs", "verb"
  result "result"
  code <<-EOS
  var result = _.groupBy(ds_dashboard_configs, function(dashboard) {
    return dashboard.verb;
  });
EOS
end

datasource "ds_dashboards_to_create" do
  # Filter out POST requests (new dashboards to create)
  run_script $js_filter_dashboards, $ds_dashboards_grouped, "create"
end

datasource "ds_dashboards_to_update" do
  # Filter out PUT requests (existing dashboards to update)
  run_script $js_filter_dashboards, $ds_dashboards_grouped, "update"
end

script "js_filter_dashboards", type: "javascript" do
  parameters "ds_dashboards_grouped", "verb"
  result "result"
  code <<-EOS
  result = ds_dashboards_grouped[verb] || [];
EOS
end

# Get existing dashboards
datasource "ds_get_dashboards" do
  request do
    auth $auth_flexera
    host rs_optima_host
    path join(["/bill-analysis/orgs/", rs_org_id, "/dashboards"])
    header "Api-Version", "0.1"
    header "User-Agent", "RS Policies"
    # ignore_status [409] # Ignore conflicts since dashboards may already exist
  end
  # result do
  #   encoding "json"
  #   field "id", jmes_path(response, "id")
  #   field "name", jmes_path(response, "name")
  #   field "config", jmes_path(response, "config")
  # end
end

# datasource "ds_create_dashboards" do
#   iterate $ds_dashboards_to_create
#   request do
#     auth $auth_flexera
#     verb "POST"
#     host rs_optima_host
#     path join(["/bill-analysis/orgs/", rs_org_id, "/dashboards"])
#     header "Api-Version", "0.1"
#     header "User-Agent", "RS Policies"
#     body_field "Area", "OrgDashboard"
#     body_field "Name", val(iter_item, "name")
#     body_field "Config", val(iter_item, "config")
#     body_field "Visibility", "public"
#     # ignore_status [409] # Ignore conflicts since dashboards may already exist
#   end
#   # result do
#   #   encoding "json"
#   #   field "id", jmes_path(response, "ID")
#   #   field "name", jmes_path(response, "Name")
#   #   field "area", jmes_path(response, "Area")
#   #   field "visibility", jmes_path(response, "Visibility")
#   #   field "created_at", jmes_path(response, "CreatedAt")
#   #   field "updated_at", jmes_path(response, "UpdatedAt")
#   #   field "dimension_value", val(iter_item, "dimension_value")
#   # end
# end

# datasource "ds_update_dashboards" do
#   iterate $ds_dashboards_to_update
#   request do
#     auth $auth_flexera
#     verb "PUT"
#     host rs_optima_host
#     path join(["/bill-analysis/orgs/", rs_org_id, "/dashboards/", val(iter_item, "id")])
#     header "Api-Version", "0.1"
#     header "User-Agent", "RS Policies"
#     body_field "Area", "OrgDashboard"
#     body_field "Name", val(iter_item, "name")
#     body_field "Config", val(iter_item, "config")
#     body_field "Visibility", "public"
#     # ignore_status [409] # Ignore conflicts since dashboards may already exist
#   end
#   # result do
#   #   encoding "json"
#   #   field "id", jmes_path(response, "ID")
#   #   field "name", jmes_path(response, "Name")
#   #   field "area", jmes_path(response, "Area")
#   #   field "visibility", jmes_path(response, "Visibility")
#   #   field "created_at", jmes_path(response, "CreatedAt")
#   #   field "updated_at", jmes_path(response, "UpdatedAt")
#   #   field "dimension_value", val(iter_item, "dimension_value")
#   # end
# end

###############################################################################
# Policy
###############################################################################

policy "pol_dynamic_dashboards" do
  validate $ds_dashboard_configs do
    summary_template "Dynamic Dashboards: {{ len data }} Dashboards for {{ parameters.param_dashboard_group_dimension }}"
    check eq(size(data), 0 ) # Trigger incident if there are any results
    escalate $esc_upsert_dashboards
    escalate $esc_delete_dashboards
    export do
      resource_level true
      field "id" do
        label "Dashboard ID"
      end
      field "name" do
        label "Dashboard Name"
      end
      field "dimension_name" do
        label "Dimension Name"
      end
      field "dimension_value" do
        label "Dimension Value"
      end
      field "widget_dimension" do
        label "Widget Dimension"
      end
      field "widget_dimension_values" do
        label "Widget Dimension Values"
      end
      field "config" do
        label "Dashboard JSON"
      end
    end
  end
end

###############################################################################
# Escalations
###############################################################################

escalation "esc_upsert_dashboards" do
  automatic false
  label "Create/Update Dynamic Dashboards"
  description "Approval to create/update the dynamic dashboards"
  run "upsert_dashboards", data, rs_org_id, rs_optima_host
end

escalation "esc_delete_dashboards" do
  automatic false
  label "Delete Dynamic Dashboards"
  description "Approval to delete the dynamic dashboards"
  run "delete_dashboards", data, rs_org_id, rs_optima_host
end

###############################################################################
# Cloud Workflow
###############################################################################

define upsert_dashboards($data, $rs_org_id, $rs_optima_host) do
  $$all_responses = []
  $$debug = []

  foreach $dashboard in $data do
    sub on_error: handle_error() do
      call modify_dashboard($dashboard, $rs_org_id, $rs_optima_host)
    end
  end

  # If we encountered any errors, use `raise` to mark the CWF process as errored
  if inspect($$errors) != "null"
    raise join($$errors, "\n")
  end

  # If we made it here, all actions completed successfully
  # Celebrate Success!
  task_label("Process completed successfully!")
end

define delete_dashboards($data, $rs_org_id, $rs_optima_host) do
  $$all_responses = []
  $$debug = []

  foreach $dashboard in $data do
    sub on_error: handle_error() do
      call modify_dashboard($dashboard, $rs_org_id, $rs_optima_host, true) # Pass true to delete
    end
  end

  # If we encountered any errors, use `raise` to mark the CWF process as errored
  if inspect($$errors) != "null"
    raise join($$errors, "\n")
  end

  # If we made it here, all actions completed successfully
  # Celebrate Success!
  task_label("Process completed successfully!")
end

define modify_dashboard($dashboard, $rs_org_id, $rs_optima_host, $delete) do
  # Default to create
  $dashboard_id = ""
  $verb = "post"
  # If we have a valid Dashboard ID, we will update it and use PUT
  if size($dashboard["id"]) != 0 && $dashboard["id"] != "" && $dashboard["id"] != "null"
    $dashboard_id = "/"+$dashboard["id"]
    $verb = "put"
    # If delete is true, we will delete the dashboard instead of modify
    if $delete == true
      $verb = "delete"
    end
  end
  task_label(upcase($verb)+" Dashboard: " + $dashboard["name"])
  $response = http_request(
    auth: $$auth_flexera,
    verb: $verb,
    https: true,
    host: $rs_optima_host,
    href: join(["/bill-analysis/orgs/", $rs_org_id, "/dashboards", $dashboard_id]),
    headers: { "Api-Version": "0.1" },
    body: {
      "Area": "OrgDashboard",
      "Name": $dashboard["name"],
      "Config": $dashboard["config"],
      "Visibility": "public"
    }
  )
  $$all_responses << $response
  $debug = to_json({
    "response": $response,
    "item": $item,
    "governance_host": $governance_host
  })
  $$debug << $debug
  if $response["code"] < 200 || $response["code"] >= 300
      call log_error("Error " + upcase($verb) + " dashboard: " + $dashboard["name"] + " - " + $response["body"])
  end
  task_label("Completed " + upcase($verb) + " Dashboard: " + $dashboard["name"])
end

# CWF function to handle errors
define handle_error() do
  if !$$errors
    $$errors = []
  end
  $$errors << $_error["type"] + ": " + $_error["message"]
  # We check for errors at the end, and raise them all together
  # Skip errors handled by this definition
  $_error_behavior = "skip"
end
# CWF function to handle errors
define log_error($err) do
  if !$$errors
    $$errors = []
  end
  $$errors << $err
end
