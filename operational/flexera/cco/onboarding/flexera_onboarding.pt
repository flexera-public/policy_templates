name "Flexera Onboarding"
rs_pt_ver 20180301
type "policy"
short_description "Provides a starting point for onboarding Flexera, and maturing your FinOps practice. See the [README](https://github.com/flexera-public/policy_templates/tree/master/operational/flexera/cco/onboarding/) and [docs.flexera.com/flexera/EN/Automation](https://docs.flexera.com/flexera/EN/Automation/AutomationGS.htm) to learn more."
long_description ""
doc_link "https://github.com/flexera-public/policy_templates/tree/master/operational/flexera/cco/onboarding/"
severity "low"
default_frequency "15 minutes"
category "Operational"
info(
  publish: "true",
  version: "0.1.3",
  provider: "Flexera",
  service: "All",
  policy_set: "N/A"
)

###############################################################################
# Parameters
###############################################################################

parameter "param_email" do
  type "list"
  category "Policy Settings"
  label "Email Addresses"
  description "A list of email addresses to notify."
  default []
end

parameter "param_checks_exclude" do
  type "list"
  category "Policy Settings"
  label "Exclude Checks"
  description "A list of checks to exclude from the \"To Do\" incident results."
  default []
end

###############################################################################
# Authentication
###############################################################################

# This PT should only require Flexera Credentials
credentials "auth_flexera" do
  schemes "oauth2"
  label "Flexera"
  description "Select Flexera One OAuth2 credentials"
  tags "provider=flexera"
end

###############################################################################
# Pagination
###############################################################################

pagination "pagination_flexera" do
  get_page_marker do
    # Pagination provided by Flexera Engineering.  2024-07.  Maybe eventually a better way to implement..?
    body_path jq(response, 'try(.nextPage | split("skipToken=") | .[1] | sub("%3D";"=";"g") | sub("%253D";"=";"g")) catch null') # The skipToken is url encoded, so we need to decode the %3D and %253D to = .  This is not ideal implementation this seems to be enough without a true urldecode function
  end
  set_page_marker do
    query "skipToken"
  end
end

###############################################################################
# Datasources & Scripts
###############################################################################

# Get region-specific Flexera API endpoints
datasource "ds_flexera_api_hosts" do
  run_script $js_flexera_api_hosts, rs_optima_host
end

script "js_flexera_api_hosts", type: "javascript" do
  parameters "rs_optima_host"
  result "result"
  code <<-EOS
  host_table = {
    "api.optima.flexeraeng.com": {
      ui: "app.flexera.com",
      flexera: "api.flexera.com",
      fsm: "api.fsm.flexeraeng.com"
    },
    "api.optima-eu.flexeraeng.com": {
      ui: "app.flexera.eu",
      flexera: "api.flexera.eu",
      fsm: "api.fsm-eu.flexeraeng.com"
    },
    "api.optima-apac.flexeraeng.com": {
      ui: "app.flexera.au",
      flexera: "api.flexera.au",
      fsm: "api.fsm-apac.flexeraeng.com"
    }
  }

  result = host_table[rs_optima_host]
EOS
end

# Get Service Account Details
datasource "ds_service_accounts" do
  request do
    auth $auth_flexera
    host val($ds_flexera_api_hosts, 'flexera')
    path join(["/iam/v1/orgs/", rs_org_id, "/service-accounts"])
  end
end

# Get Service Account Client Details
datasource "ds_service_account_clients" do
  iterate $ds_service_accounts
  request do
    auth $auth_flexera
    host val($ds_flexera_api_hosts, 'flexera')
    path join(["/iam/v1/orgs/", rs_org_id, "/service-accounts/", val(iter_item, "id"), "/clients"])
  end
  result do
    encoding "json"
    collect jmes_path(response, "[*]") do
      field "service_account", iter_item
      field "clientId", jq(col_item, ".clientId")
      field "createdAt", jq(col_item, ".createdAt")
      field "createdBy", jq(col_item, ".createdBy")
    end
  end
end

datasource "ds_result_service_account" do
  run_script $js_result_service_account, $ds_service_accounts, $ds_service_account_clients
end

script "js_result_service_account", type: "javascript" do
  parameters "ds_service_accounts", "ds_service_account_clients"
  result "check_results"
  code <<-EOS
  check_results = [];
  // Check to see if there is at least one Service Account
  if (ds_service_accounts.length > 0) {
    // Check to see if there is at least one Service Account Client for at least one Service Account
    if (ds_service_account_clients.length == 0) {
      // Details from official docs page
      // https://developer.flexera.com/docs/api/iam/v1#/Service%20Account%20Client
      details = [
        "Each service account client belongs to a service account, and consists of a clientId and clientSecret. The clientSecret is a sensitive credential and must be stored securely. Lost or compromised clients should be deleted immediately.",
        "Generally, only one of the service account's clients should be in use at a time. The exception is during a no-downtime credential rotation, a new client must be generated and supplied to the running application acting as a service account, before the previous client is deleted.",
        "The service account client's clientId and clientSecret are used to authenticate with Flexera One's API. After authentication, the application's permission in the Flexera One API is determined by the roles assigned to the service account.",
        "More details in the [Flexera API > Service Account Client Documentation](https://developer.flexera.com/docs/api/iam/v1#/Service%20Account%20Client)"
      ]
      check_results.push({
        "name": "First Service Account Client",
        "severity": "high",
        "result": "fail",
        "details": "No Service Account Clients found.\\n\\n"+details.join("\\n\\n")
      });
    } else {
      // Check to see if there is at least one Service Account Client for at least one Service Account
      check_results.push({
        "name": "First Service Account Client",
        "severity": "high",
        "result": "pass",
        "details": ds_service_account_clients.length+" Service Account Client(s) found."
      });
      //
    }
  }
EOS
end

# Get Bill Connection Details
datasource "ds_bill_connects" do
  request do
    auth $auth_flexera
    host val($ds_flexera_api_hosts, 'flexera')
    path join(["/finops-onboarding/v1/orgs/", rs_org_id, "/bill-connects"])
  end
  result do
    # https://developer.flexera.com/docs/api/finops-onboarding/v1#/Bill%20Connect/Bill%20Connect%23index
    collect jmes_path(response, "values[*]") do
      field "aws", jq(col_item, ".aws")
      field "azureEa", jq(col_item, ".azureEa")
      field "azureEaManagement", jq(col_item, ".azureEaManagement")
      field "cbi", jq(col_item, ".cbi")
      field "cbiAzureMca", jq(col_item, ".cbiAzureMca")
      field "createdat", jq(col_item, ".createdAt")
      field "gcp", jq(col_item, ".gcp")
      field "id", jq(col_item, ".id")
      field "kind", jq(col_item, ".kind")
      # use jq to remove "finops:bill-connect-" from the beginning of the kind value
      field "type", jq(col_item, '.kind | sub("finops:bill-connect-"; "")')
      field "updatedAt", jq(col_item, ".updatedAt")
    end
  end
end

# Get Bill Connect Validations
# datasource "ds_bill_connect_validations" do
#   iterate jq($ds_bill_connects, '[ .[] | select(.kind != "finops:bill-connect-azure-ea") ]', "array")
#   request do
#     auth $auth_flexera
#     host val($ds_flexera_api_hosts, 'flexera')
#     path join(["/finops-onboarding/v1/orgs/", rs_org_id, "/bill-connects/", val(iter_item, "type"), "/", val(iter_item, "id"), "/validation"])
#   end
#   result do
#     encoding "json"
#     collect jq(response, ".") do
#       field "bill_connect", iter_item
#       field "validation", jq(col_item, ".")
#     end
#   end
# end

datasource "ds_bill_connect_validations" do
  request do
    auth $auth_flexera
    host val($ds_flexera_api_hosts, 'flexera')
    path join(["/finops-onboarding/v1/orgs/", rs_org_id, "/bill-connects/validations"])
  end
end

datasource "ds_result_bill_connects" do
  run_script $js_result_bill_connects, $ds_bill_connect_validations, $ds_credentials, $ds_flexera_api_hosts, rs_org_id, rs_project_id
end

script "js_result_bill_connects", type: "javascript" do
  parameters "ds_bill_connect_validations", "ds_credentials", "ds_flexera_api_hosts", "rs_org_id", "rs_project_id"
  result "check_results"
  code <<-EOS
  check_results = [];
  // Check to see if there is at least one Bill Connect
  if (ds_bill_connect_validations.values.length == 0) {
    check_results.push({
      "name": "First Bill Connect",
      "severity": "high",
      "result": "fail",
      "details": "No Bill Connect found."
    });
  } else {
    check_results.push({
      "name": "First Bill Connect",
      "severity": "high",
      "result": "pass",
      "details": ds_bill_connect_validations.values.length+" Bill Connect(s) found."
    });
  }
  // Check to see if any Bill Connects have failed validations
  var failed_validations = _.filter(ds_bill_connect_validations.values, function (bill_connect) {
    return !bill_connect.valid;
  });
  if (failed_validations.length > 0) {
    check_results.push({
      "name": "Bill Connect Validation",
      "severity": "high",
      "result": "fail",
      "details": failed_validations.length+" Bill Connect(s) have failed validations.  Bill Connect IDs: "+failed_validations.map(function (bill_connect) {
        return "["+bill_connect.billId+"](https://"+ds_flexera_api_hosts.ui+"/orgs/"+rs_org_id+"/optima/cloud-settings/bill-processing?accountImportHistory="+bill_connect.billId+")";
      }).join(", ")
    });
  } else {
    check_results.push({
      "name": "Bill Connect Validation",
      "severity": "high",
      "result": "pass",
      "details": "All "+ds_bill_connect_validations.values.length+" Bill Connects have passed validations."
    });
  }
  // Check to see if there is an AWS, Azure, Google
  var checks = [
    {
      "name": "AWS",
      "automation_docs_url": "https://docs.flexera.com/flexera/EN/Automation/ProviderCredentials.htm#automationadmin_3335267112_1121575",
      "details": [
        "AWS bill connect provides a resource for registering and maintaining AWS bill connections. This offer two ways of connecting AWS bills, using IAM Role (cross-account role) or IAM user. The preferred method for connecting to AWS, cross-account roles allow you to grant Flexera access to your account in a defined and constrained way. IAM users provide broad access to AWS services. Where possible, we recommend using cross-account roles.",
        "See [Flexera Docs > FinOps Bill Connect Configs AWS](https://docs.flexera.com/flexera/EN/Optima/OptimaBillConnectConfigsAWS.htm) for more details."
      ],
      "regex": /aws/
    },
    {
      "name": "Azure",
      "automation_docs_url": "https://docs.flexera.com/flexera/EN/Automation/ProviderCredentials.htm#automationadmin_3335267112_1121576",
      "details": [
        "The Azure EA and Azure MCA bill connects uses Azure's Service Principals with a Client Secret under the hood for authentication with Microsoft's APIs.",
        "[Azure EA (Enterprise Agreement) Bill Connect](https://docs.flexera.com/flexera/EN/Optima/BillConnectConfigsAzureEALegacy.htm) provides a resource for registering and maintaining Azure EA Bill Connections at Billing or Enrollment Account scopes. ",
        "[Azure MCA (Microsoft Customer Agreement) Bill Connect](https://docs.flexera.com/flexera/EN/Optima/BillConnectConfigsAzureEAModernCommerce.htm) provides a resource for registering and maintaining Azure MCA Bill Connections at the Billing Account scope. Billing account for the Microsoft Customer Agreement contains one or more billing profiles that let you manage your invoices and payment methods. Each billing profile contains one or more invoice sections that let you organize costs on the billing profile's invoice."
      ],
      "regex": /azure/
    },
    {
      "name": "Google",
      "automation_docs_url": "https://docs.flexera.com/flexera/EN/Automation/ProviderCredentials.htm#automationadmin_3335267112_1121577",
      "details": [
        "GCP (Google Cloud Platform) bill connect provides a resource for registering and maintaining GCP bill connections.",
        "See [Flexera Docs > FinOps Bill Connect Configs GCP](https://docs.flexera.com/flexera/EN/Optima/OptimaBillConnectConfigsGoogle.htm) for more details."
      ],
      "regex": /gcp|google|gce/
    }
  ];
  // for each check, filter the bill connects to see if there is at least one
  _.each(checks, function(check) {
    // Check for at least one bill connect that matches the regex
    var bill_connect = _.filter(ds_bill_connect_validations.values, function (bill_connect) {
      return check.regex.test(bill_connect.kind);
    });
    if (bill_connect.length == 0) {
      check_results.push({
        "name": check.name+" Bill Connect",
        "severity": "high",
        "result": "fail",
        "details": "No "+check.name+" Bill Connect found.\\n\\n"+check.details.join("\\n\\n")
      });
    } else {
      check_results.push({
        "name": check.name+" Bill Connect",
        "severity": "high",
        "result": "pass",
        "details": bill_connect.length+" "+check.name+" Bill Connect(s) found."
      });
      // If we have a Bill Connect, we recommend setting up an automation credential as well for that billing account
      // Check for at least one credential that matches the conditions
      var credential = _.filter(ds_credentials, function (c) {
        var provider_tag = _.find(c.tags, function (tag) {
          return tag.key == "provider";
        });
        if (provider_tag == null) {
          return false;
        }
        return check.regex.test(provider_tag.value);
      });
      if (credential.length == 0) {
        check_results.push({
          "name": check.name+" Automation Credential",
          "severity": "high",
          "result": "fail",
          "details": "No "+check.name+" Automation Credential(s) found.  Recommend setting up an automation credential so you can deploy Policy Templates and increase visibility into potential optimization opportunities.\\n\\nYou can remediate this by creating the bill connection following steps outlined here: [Automation > Provider-Specific Credentials > "+check.name+"]("+check.automation_docs_url+")"
        });
      } else {
        check_results.push({
          "name": check.name+" Automation Credential",
          "severity": "high",
          "result": "pass",
          "details": credential.length+" "+check.name+" Automation Credential(s) found: "+credential.map(function (c) {
            return "["+c.name+"](https://"+ds_flexera_api_hosts.ui+"/orgs/"+rs_org_id+"/automation/projects/"+rs_project_id+"/credentials/"+c.id+")";
          }).join(", ")
        });
      }
    }
  });
EOS
end

# Get Applied Policy Details
# Both Applied Policies and Policy Aggregates are required for this policy
datasource "ds_applied_policies" do
  request do
    auth $auth_flexera
    pagination $pagination_flexera
    host val($ds_flexera_api_hosts, 'flexera')
    path join(["/policy/v1/orgs/", rs_org_id, "/projects/", rs_project_id, "/applied-policies"])
    query "limit", "5000"
    query "view", "extended"
  end
  result do
    collect jmes_path(response, "values[*]") do
      field "id", jq(col_item, ".id")
      field "policyAggregateId", jq(col_item, ".policyAggregateId")
      field "name", jq(col_item, ".name")
      field "info", jq(col_item, ".info")
      field "policyTemplate", jq(col_item, ".policyTemplate")
      field "publishedTemplate", jq(col_item, ".publishedTemplate")
      field "metaParentPolicyId", jq(col_item, ".metaParentPolicyId")
      field "options", jq(col_item, ".options")
      field "status", jq(col_item, ".status")
    end
  end
end

# We cannot use rs_governance_host // Governan ce API because it does not support Service Account auth
# Coming Q4:
#   Tatiana Dubovchenko: We plan to work on Incident API in Q4
#   sent on August 7, 2024 1:04 PM

datasource "ds_applied_policies_incidents" do
  request do
    auth $auth_flexera
    host rs_governance_host
    path join(["/api/governance/projects/", rs_project_id, "/incidents"])
    query "state", "triggered"
    header "User-Agent", "RS Policies"
    header "Api-Version", "1.0"
  end
  result do
    collect jmes_path(response, "items[*]") do
      field "applied_policy_id", jq(col_item, ".applied_policy.id") # Used to map incident to applied policy
      field "id", jq(col_item, ".id") # Used to create link to incident in UI
      field "summary", jq(col_item, ".summary") # Used to create link to incident in UI
      # field "applied_policy", jq(col_item, ".applied_policy")
    end
  end
end

# Unused in v0.1.0 but may be useful in future versions
# datasource "ds_applied_policy_aggregates" do
#   request do
#     auth $auth_flexera
#     pagination $pagination_flexera
#     host val($ds_flexera_api_hosts, 'flexera')
#     path join(["/policy/v1/orgs/", rs_org_id, "/policy-aggregates"])
#     query "limit", "5000"
#   end
# end

# Get Published Catalog Policy Template List
datasource "ds_published_templates" do
  request do
    auth $auth_flexera
    pagination $pagination_flexera
    host val($ds_flexera_api_hosts, 'flexera')
    path join(["/policy/v1/orgs/", rs_org_id, "/published-templates"])
    query "limit", "5000"
    query "view", "extended"
  end
  result do
    collect jmes_path(response, "values[*]") do
      field "id", jq(col_item, ".id")
      field "name", jq(col_item, ".name")
      field "ref", jq(col_item, ".ref")
      field "builtIn", jq(col_item, ".builtIn")
      field "fingerprint", jq(col_item, ".fingerprint")
      field "policyTemplateFingerprint", jq(col_item, ".policyTemplateFingerprint")
      field "info", jq(col_item, ".info")
      field "credentials", jq(col_item, ".credentials")
      field "updatedAt", jq(col_item, ".updatedAt")
    end
  end
end

# Get Credentials
datasource "ds_credentials" do
  request do
    auth $auth_flexera
    pagination $pagination_flexera
    host val($ds_flexera_api_hosts, 'flexera')
    path join(["/cred/v2/projects/", rs_project_id, "/credentials"])
    query "limit", "5000"
    query "view", "extended"
  end
  result do
    collect jmes_path(response, "values[*]") do
      field "id", jq(col_item, ".id")
      field "name", jq(col_item, ".name")
      field "tags", jq(col_item, ".tags")
      field "scheme", jq(col_item, ".scheme")
      field "kind", jq(col_item, ".kind")
      field "ref", jq(col_item, ".ref")
    end
  end
end

# Get "Active" Catalog Policy Template List
# This is the source of truth for what should be applied to catalog
# This is public data hosted in GitHub and managed by Flexera
# Unused in v0.1.0 but may be useful in future versions
# datasource "ds_active_policy_list" do
#   request do
#     host "raw.githubusercontent.com"
#     path "/flexera-public/policy_templates/master/data/active_policy_list/active_policy_list.json"
#     header "User-Agent", "RS Policies"
#   end
# end

datasource "ds_generally_recommended_templates_json" do
  request do
    host "raw.githubusercontent.com"
    path "/flexera-public/policy_templates/master/data/active_policy_list/generally_recommended_templates.json"
  end
end

# Statically defined list of policy templates that are recommended for onboarding
datasource "ds_result_applied_policy" do
  run_script $js_result_applied_policy, $ds_credentials, $ds_applied_policies, $ds_applied_policies_incidents, $ds_published_templates, $ds_bill_connects, $ds_flexera_api_hosts, rs_org_id, rs_project_id
end

script "js_result_applied_policy", type: "javascript" do
  parameters "ds_credentials", "ds_applied_policies", "ds_applied_policies_incidents", "ds_published_templates", "ds_bill_connects", "ds_flexera_api_hosts", "rs_org_id", "rs_project_id"
  result "check_results"
  code <<-EOS
  check_results = [];
  // Check to see if there is at least one Applied Policy
  if (ds_applied_policies.length == 0) {
    check_results.push({
      "name": "First Applied Policy",
      "severity": "high",
      "result": "fail",
      "details": "No Applied Policy found."
    });
  } else {
    check_results.push({
      "name": "First Applied Policy",
      "severity": "high",
      "result": "pass",
      "details": ds_applied_policies.length+" Applied Policy(s) found."
    });
    // Check to see if there are any Applied Policies that are in error status
    var error_policies = _.filter(ds_applied_policies, function (applied_policy) {
      return applied_policy.status == "error";
    });
    if (error_policies.length > 0) {
      percent = Math.round((error_policies.length / ds_applied_policies.length) * 100);
      // Loop through all Applied Policies to aggregate the children in error under the parent
      // This will help with the formatting the results, instead of 1 bullet per applied policy (which there can be thousands of errored applied policies with Meta/Children policies)
      error_policies_grouped = _.groupBy(error_policies, function (applied_policy) {
        return applied_policy.metaParentPolicyId;
      });
      // Construct the list of error policies
      var error_policies_list = [];
      _.each(_.keys(error_policies_grouped), function (metaParentPolicyId) {
        // key for child policies with no parent is a string with value "undefined"
        // This is result from _.groupBy() function.  normally we would expect null or "" from Flexera API
        if (metaParentPolicyId != "undefined" && metaParentPolicyId.length > 0) {
          // Find the parent policy
          parent_policy = _.find(ds_applied_policies, function (ap) {
            return ap.id == metaParentPolicyId;
          });
          if (parent_policy == null) {
            parent_policy = {"name": "*Parent Applied Policy Terminated*", "id": metaParentPolicyId};
          }
          // https://app.flexera.com/orgs/30719/automation/applied-policies/projects/131226?noIndex=1&policyId=62f55a98794f000001196456
          // Construct the list of children policies
          children_policies = error_policies_grouped[metaParentPolicyId].length
          error_policies_list.push(" - ["+parent_policy.name+"](https://"+ds_flexera_api_hosts.ui+"/orgs/"+rs_org_id+"/automation/applied-policies/projects/"+rs_project_id+"?noIndex=1&policyId="+parent_policy.id+") ("+children_policies+" Child Policy(s) in error)");
        } else {
          // No parent policy, just list the children policies
          _.each(error_policies_grouped[metaParentPolicyId], function (applied_policy) {
            error_policies_list.push(" - ["+applied_policy.name+"](https://"+ds_flexera_api_hosts.ui+"/orgs/"+rs_org_id+"/automation/applied-policies/projects/"+rs_project_id+"?noIndex=1&policyId="+applied_policy.id+")");
          });
        }
        // Add the parent policy and children policies to the error_policies_list
      });
      // Add fail check result
      check_results.push({
        "name": "Error Applied Policy",
        "severity": "medium",
        "result": "fail",
        "details": error_policies.length+" Applied Policy(s) are in error status which is "+percent.toString()+"% of total "+ds_applied_policies.length+" applied policies.\\n\\nApplied Policy in error state: \\n"+error_policies_list.join("\\n")
      });
    } else {
      check_results.push({
        "name": "Error Applied Policy",
        "severity": "medium",
        "result": "pass",
        "details": "All "+ds_applied_policies.length+" Applied Policy(s) are in a valid status."
      });
    }
  }
EOS
end

datasource "ds_result_fail_generally_recommended_templates" do
  run_script $js_result_fail_generally_recommended_templates, $ds_credentials, $ds_applied_policies, $ds_applied_policies_incidents, $ds_published_templates, $ds_generally_recommended_templates_json, $ds_bill_connects, $ds_flexera_api_hosts, rs_org_id, rs_project_id
end

script "js_result_fail_generally_recommended_templates", type: "javascript" do
  parameters "ds_credentials", "ds_applied_policies", "ds_applied_policies_incidents", "ds_published_templates", "ds_generally_recommended_templates_json", "ds_bill_connects", "ds_flexera_api_hosts", "rs_org_id", "rs_project_id"
  result "check_results"
  code <<-EOS
  check_results = [];

  // Check if we have at least 1 AWS, Azure, or Google bill connect
  // This is used later but we can filter the list now
  publiccloudBillConnects = _.filter(ds_bill_connects, function (bill_connect) {
    return bill_connect.kind.indexOf("aws") > -1 || bill_connect.kind.indexOf("azure") > -1 || bill_connect.kind.indexOf("google") > -1 || bill_connect.kind.indexOf("gcp") > -1 || bill_connect.kind.indexOf("gce") > -1;
  });

  // Add "Flexera Onboarding" to ds_generally_recommended_templates
  // We have some checks that we want to run for this policy template
  // Currently not included in the recommended templates list because it's not in the Catalog but it could be and then this could be removed.
  ds_generally_recommended_templates_json["flexera"] = ["Flexera Onboarding"];

  // For each vendor in the common policy list
  _.each(_.keys(ds_generally_recommended_templates_json), function(vendor) {
    var bill_connects = _.filter(ds_bill_connects, function (bill_connect) {
      // If vendor == google, look for "gcp" instead
      if (vendor == "google") {
        vendor = "gcp"
      }
      // Match if bill_connect.kind contains vendor string
      return bill_connect.kind.indexOf(vendor) > -1;
    });
    // Only loop through policy templates if we have at least one bill connect for the vendor
    if (bill_connects.length >= 1) {
      // For each of the PT for the vendor in the common policy list
      _.each(ds_generally_recommended_templates_json[vendor], function(pt) {
        // Check if there is a bill connect for the vendor
        // Check if there is a credential for the vendor
        var credentials = _.filter(ds_credentials, function (credential) {
          // Find the provider tag from the tags on the credentials
          var provider_tag = _.find(credential.tags, function (tag) {
            return tag.key == "provider";
          });
          // If not provider tag, then we can't match this credential to a vendor and exclude from filter
          if (provider_tag == null) {
            return false;
          }
          // Else, check if the provider tag value contains the vendor string
          // Lowercase the vendor string since they are defined in lowercase in the provider tag
          var match = vendor.toLowerCase();
          // Check if the vendor is "google"
          // We need to handle this differently because the provider tag value is not an exact match (can be google or gcp)
          if (vendor == "google") {
            var regex = /gcp|gce|google/;
            return regex.test(provider_tag.value);
          } else {
            // for all other vendors, we can do a simple indexOf check
            return provider_tag.value.indexOf(vendor) > -1;
          }
        });

        // Only check the recommended policy if:
        //   - There is at least 1 bill connect for the vendor AND 1 credential for the vendor
        //   OR
        //   - Vendor is "flexera"
        //     We can safely assume "flexera" provider exists b/c it is required to run this policy,
        //     But only proceed with those Flexera Policy recommendations there is at least 1 "public cloud" (aws, azure, google) bill connect first
        if ((bill_connects.length >= 1 && credentials.length >= 1) || (vendor == "flexera" && publiccloudBillConnects.length >= 1)) {
          // filter the applied policies to see if the policyTemplate.name contains the recommended policy template
          var policy = _.filter(ds_applied_policies, function (applied_policy) {
            // Check to see if it's a policyTemplate or publishedTemplate
            if (typeof applied_policy.policyTemplate == "object") {
              // check if pt.name is in the policyTemplate.name
              return applied_policy.policyTemplate.name.indexOf(pt) > -1;
            } else {
              // else, published template
              // check if pt.name is in the publishedTemplate.name
              return applied_policy.publishedTemplate.name.indexOf(pt) > -1;
            }
          });
          if (policy.length == 0) {
            // Get the PT details from the catalog as they are helpful in the fail detail for remediation
            ptCatalogId = "";
            var published_template = _.find(ds_published_templates, function (published_template) {
              return published_template.name == pt;
            });
            if (typeof published_template == "object" && typeof published_template.id == "string") {
              // Add URL query parameter to the catalog URL to load PT details automatically
              ptCatalogId = "?templateId="+published_template.id;
            }
            check_results.push({
              // "name": "Recommended Policy Template: "+pt,
              // "severity": "medium",
              // "result": "fail",
              "name": pt,
              "details": "The "+pt+" policy is not applied. Recommend applying this policy template to increase visibility into potential optimization opportunities.\\n\\nYou can remediate this by applying the policy template from [Automation > Applied Policies > Catalog > Search for `'"+pt+"'`](https://"+ds_flexera_api_hosts.ui+"/orgs/"+rs_org_id+"/automation/catalog"+ptCatalogId+")"
            });
          }
        }
      });
    }
  });
EOS
end

datasource "ds_check_specific_policy_templates" do
  run_script $js_check_specific_policy_templates, $ds_credentials, $ds_applied_policies, $ds_applied_policies_incidents, $ds_published_templates, $ds_generally_recommended_templates_json, $ds_bill_connects, $ds_flexera_api_hosts, rs_org_id, rs_project_id
end

script "js_check_specific_policy_templates", type: "javascript" do
  parameters "ds_credentials", "ds_applied_policies", "ds_applied_policies_incidents", "ds_published_templates", "ds_generally_recommended_templates_json", "ds_bill_connects", "ds_flexera_api_hosts", "rs_org_id", "rs_project_id"
  result "check_results"
  code <<-EOS
  check_results = [];

  // pt_check_flag is an object to hold the status of a check for each policy template
  // This is used in cases where only 1 policy template (out of potentially many) meets the criteria
  // While looping through all PTs, if the check pases, the pt_check_flat value for that PT check is set to "pass"
  // After looping through all PTs, we use pt_check_flag to determine if we should add a pass or fail check_results entry
  pt_check_flag = {}

  // For each ds_applied_policies_incidents
  _.each(ds_applied_policies, function(applied_policy) {
    if (applied_policy != null) {
      // Get the Policy Template name (pt) from the applied_policy
      var pt = null;
      // Check to see if it's a policyTemplate or publishedTemplate
      if (typeof applied_policy.policyTemplate == "object") {
        pt = applied_policy.policyTemplate.name;
      } else if (typeof applied_policy.publishedTemplate == "object") {
        // else, publishedTemplate
        pt = applied_policy.publishedTemplate.name;
      } else {
        // This is not expected
        pt = "Unknown";
      }

      // Check if the Policy Template has any Incidents
      incidents = _.filter(ds_applied_policies_incidents, function (incident) {
        return incident.applied_policy_id == applied_policy.id;
      });

      // Begin Flexera Onboarding checks
      if (pt == "Flexera Onboarding") {
        // If we have incidents for the PT
        if (incidents.length > 0) {
          // Check if any of the incidents match "Flexera Onboarding: Apply Recommended Policy Templates"
          var apply_recommended_policy_incidents = _.filter(incidents, function (incident) {
            return incident.summary == "Flexera Onboarding: Apply Recommended Policy Templates";
          });
          if (apply_recommended_policy_incidents.length > 0) {
            check_results.push({
              "name": "Flexera Onboarding: Apply Recommended Policy Templates",
              "severity": "medium",
              "result": "fail",
              "details": "The "+pt+" policy template has an incident triggered to apply recommended policy templates.  Recommend reviewing the incidents to determine if any action is needed.\\n\\nTo remediate this, you can view the incidents in the UI Automation > Incidents > Search for '"+pt+"' or use this direct link:\\n\\n"+apply_recommended_policy_incidents.map(function (incident) {
                return " - ["+incident.summary+"](https://"+ds_flexera_api_hosts.ui+"/orgs/"+rs_org_id+"/automation/incidents/projects/"+rs_project_id+"?incidentId="+incident.id+")";
              }).join("\\n")
            });
          } else {
            check_results.push({
              "name": "Flexera Onboarding: Apply Recommended Policy Templates",
              "severity": "medium",
              "result": "pass",
              "details": "The "+pt+" policy template has no incidents triggered to apply recommended policy templates."
            });
          }

          // Check if any of the incidents match "Flexera Onboarding: Create Service Account"
          var create_service_account_incidents = _.filter(incidents, function (incident) {
            return incident.summary == "Flexera Onboarding: Create Service Account";
          });
          if (create_service_account_incidents.length > 0) {
            check_results.push({
              "name": "Flexera Onboarding: Create Service Account",
              "severity": "medium",
              "result": "fail",
              "details": "The "+pt+" policy template has an incident triggered to help create a service account.  Recommend reviewing the incidents to take the necessary action and remediate this recommended task.\\n\\nTo remediate this, you can view the incidents in the UI Automation > Incidents > Search for '"+pt+"' or use this direct link:\\n\\n"+create_service_account_incidents.map(function (incident) {
                return " - ["+incident.summary+"](https://"+ds_flexera_api_hosts.ui+"/orgs/"+rs_org_id+"/automation/incidents/projects/"+rs_project_id+"?incidentId="+incident.id+")";
              }).join("\\n")
            });
          } else {
            check_results.push({
              "name": "Flexera Onboarding: Create Service Account",
              "severity": "medium",
              "result": "pass",
              "details": "The "+pt+" policy template has no incidents triggered to help create a service account."
            });
          }

        } else {
          check_results.push({
            "name": "Flexera Onboarding Incidents",
            "severity": "medium",
            "result": "pass",
            "details": "The "+pt+" policy template has no incidents triggered."
          });
        }
      }
      // End Flexera Onboarding checks

      // Begin Flexera Automation Outdated Applied Policies checks
      if (pt == "Flexera Automation Outdated Applied Policies") {
        // If we have incidents for the PT
        if (incidents.length > 0) {
          check_results.push({
            "name": "Flexera Automation Outdated Applied Policies",
            "severity": "medium",
            "result": "fail",
            "details": "The "+pt+" policy template has "+incidents.length+" incident(s) triggered.  Recommend reviewing the incidents to determine if any action is needed.\\n\\nTo remediate this, you can view the incidents in the UI Automation > Incidents > Search for '"+pt+"' or use these direct link(s):\\n\\n"+incidents.map(function (incident) {
              return " - ["+incident.summary+"](https://"+ds_flexera_api_hosts.ui+"/orgs/"+rs_org_id+"/automation/incidents/projects/"+rs_project_id+"?incidentId="+incident.id+")";
            }).join("\\n")
          });
        } else {
          check_results.push({
            "name": "Flexera Automation Outdated Applied Policies",
            "severity": "medium",
            "result": "pass",
            "details": "The "+pt+" policy template has no incidents triggered."
          });
        }

        // Check that the policy option "param_automatic_action" value contains "Update Applied Policies"
        var param_automatic_action = _.find(applied_policy.options, function (option) {
          return option.name == "param_automatic_action";
        });

        var compliance = false
        if (param_automatic_action != null && typeof param_automatic_action.value == "array") {
          // If a param is found, check if the value contains "Update Applied Policies"
          compliance = _.contains(param_automatic_action.value, "Update Applied Policies");
        }

        var ptUrl = "#"
        // URL depends if it is a published template (org scoped) or policy-template (project scoped)
        if (applied_policy.policyTemplate != null) {
          ptUrl = "https://app.flexera.com/orgs/"+rs_org_id+"/automation/applied-policies/projects/"+rs_project_id+"?noIndex=1&policyId="+applied_policy.id
        } else {
          ptUrl = "https://app.flexera.com/orgs/"+rs_org_id+"/automation/applied-policies?noIndex=1&policyId="+applied_policy.policyAggregateId
        }

        // Check if there are any compliant policies
        if (!compliance) {
          // If we are here with no compliant policies, we must have at least one policy that is non-compliant
          check_results.push({
            "name": "Flexera Automation Outdated Applied Policies: Enable Automatic Action",
            "severity": "medium",
            "result": "fail",
            "details": "The "+pt+" policy template is applied, but the policy option 'param_automatic_action' does not contain 'Update Applied Policies'.  Recommend updating the policy option to include 'Update Applied Policies' to automatically update outdated applied policies.\\n\\nTo remediate this, you can edit the applied policy template in the UI [Automation > Applied Policies > Search for '"+pt+"']("+ptUrl+")"
          });
        } else {
          // Else at least one policy is compliant
          check_results.push({
            "name": "Flexera Automation Outdated Applied Policies: Enable Automatic Action",
            "severity": "medium",
            "result": "pass",
            "details": "The ["+pt+"]("+ptUrl+") policy template is applied and configured to automatically update outdated applied policies."
          });
        }
      }
      // End Flexera Automation Outdated Applied Policies checks
    }
  });
EOS
end

# Get Rule-Based Dimensions
datasource "ds_rule_based_dimensions" do
  request do
    auth $auth_flexera
    host val($ds_flexera_api_hosts, 'flexera')
    path join(["/finops-customizations/v1/orgs/", rs_org_id, "/rule-based-dimensions"])
    # query "view", "extended"
  end
  # result do
  #   # https://developer.flexera.com/docs/api/FinOps%20Customizations#/Rule-Based%20Dimension/Rule-Based%20Dimension%23index
  #   collect jmes_path(response, "values[*]") do
  #     field "createdAt", jq(col_item, ".createdAt")
  #     field "id", jq(col_item, ".id")
  #     field "kind", jq(col_item, ".kind")
  #     field "name", jq(col_item, ".name")
  #     field "ruleListLinks", jq(col_item, ".ruleListLinks")
  #     field "updatedAt", jq(col_item, ".updatedAt")
  #   end
  # end
end

# Get Tag Dimensions
datasource "ds_tag_dimensions" do
  request do
    auth $auth_flexera
    host val($ds_flexera_api_hosts, 'flexera')
    path join(["/finops-customizations/v1/orgs/", rs_org_id, "/tag-dimensions"])
    query "view", "extended"
  end
  # result do
  #   # https://developer.flexera.com/docs/api/FinOps%20Customizations#/Tag%20Dimension/Tag%20Dimension%23index
  #   collect jmes_path(response, "values[*]") do
  #     field "createdAt", jq(col_item, ".createdAt")
  #     field "id", jq(col_item, ".id")
  #     field "kind", jq(col_item, ".kind")
  #     field "name", jq(col_item, ".name")
  #     field "tags", jq(col_item, ".tags")
  #     field "updatedAt", jq(col_item, ".updatedAt")
  #   end
  # end
end

datasource "ds_dates" do
  run_script $js_dates
end

script "js_dates", type: "javascript" do
  result "result"
  code <<-EOS
  month = new Date().toISOString()
  month = month.split('-')[0] + '-' + month.split('-')[1]

  next_month = new Date(month)
  next_month.setMonth(next_month.getMonth() + 1)
  next_month = next_month.toISOString()
  next_month = next_month.split('-')[0] + '-' + next_month.split('-')[1]

  prior_month = new Date(month)
  prior_month.setMonth(prior_month.getMonth() - 1)
  prior_month = prior_month.toISOString()
  prior_month = prior_month.split('-')[0] + '-' + prior_month.split('-')[1]

  result = {
    month: month,
    next_month: next_month,
    prior_month: prior_month
  }
EOS
end

datasource "ds_cost_dimensions" do
  run_script $js_cost_dimensions, val($ds_rule_based_dimensions, "values"), val($ds_tag_dimensions, "values")
end

script "js_cost_dimensions", type: "javascript" do
  parameters "ds_rule_based_dimensions", "ds_tag_dimensions"
  result "results"
  code <<-EOS
  // Pluck IDs from Rule-Based Dimensions and Tag Dimensions
  rbd_ids = _.pluck(ds_rule_based_dimensions, "id");
  tag_ids = _.pluck(ds_tag_dimensions, "id");
  // Combine the Rule-Based Dimension IDs and Tag Dimension IDs
  results = _.flatten([rbd_ids, tag_ids]);
EOS
end

# Get Billing Centers
datasource "ds_billing_centers" do
  request do
    auth $auth_flexera
    host rs_optima_host
    path join(["/analytics/orgs/", rs_org_id, "/billing_centers"])
    header "Api-Version", "1.0"
    header "User-Agent", "RS Policies"
    #query "view", "allocation_table"
    ignore_status [403]
  end
  result do
    encoding "json"
    # Select the Billing Centers that have "parent_id" undefined or "" (i.e. top-level Billing Centers)
    collect jmes_path(response, "[*]") do
      field "href", jq(col_item, ".href")
      field "id", jq(col_item, ".id")
      field "name", jq(col_item, ".name")
      field "parent_id", jq(col_item, ".parent_id")
    end
  end
end

# Get Billing Centers again
# Filtering on toplevel
# Separate request to workaround the Policy Template Test `run_script statements found whose parameters are not in the correct order. run_script parameters should be in the following order: script, val(iter_item, string), datasources, parameters, variables, raw values``
# Otherwise we could use existing ds_billing_centers resource and jq:
#   jq($ds_billing_centers,'.[] | select(.parent_id == null)', "array")
datasource "ds_toplevel_billing_centers" do
  request do
    auth $auth_flexera
    host rs_optima_host
    path join(["/analytics/orgs/", rs_org_id, "/billing_centers"])
    query "view", "allocation_table"
    header "Api-Version", "1.0"
    header "User-Agent", "RS Policies"
  end
  result do
    encoding "json"
    # Select the Billing Centers that have "parent_id" undefined or "" (i.e. top-level Billing Centers)
    collect jq(response, '.[] | select(.parent_id == null)' ) do
      field "href", jq(col_item, ".href")
      field "id", jq(col_item, ".id")
      field "name", jq(col_item, ".name")
      field "parent_id", jq(col_item, ".parent_id")
      field "ancestor_ids", jq(col_item, ".ancestor_ids")
      field "allocation_table", jq(col_item, ".allocation_table")
    end
  end
end

datasource "ds_cost_dimensions_costs" do
  iterate $ds_cost_dimensions
  request do
    run_script $js_cost_dimensions_costs, iter_item, $ds_toplevel_billing_centers, $ds_dates, rs_org_id, rs_optima_host
  end
  result do
    encoding "json"
    collect jmes_path(response, "rows[*]") do
      field "dimension", iter_item
      field "dimension_value", jq(col_item,".dimensions | to_entries | .[0].value")
      field "cost_nonamortized_unblended_adj", jq(col_item,".metrics.cost_nonamortized_unblended_adj")
      # field "timestamp", jq(col_item,".timestamp")
    end
  end
end

script "js_cost_dimensions_costs", type: "javascript" do
  parameters "dimension", "ds_toplevel_billing_centers", "ds_dates", "rs_org_id", "rs_optima_host"
  result "request"
  code <<-EOS
  metric = "cost_nonamortized_unblended_adj"

  var request = {
    auth: "auth_flexera",
    host: rs_optima_host,
    verb: "POST",
    path: "/bill-analysis/orgs/" + rs_org_id + "/costs/aggregated",
    body_fields: {
      "dimensions": [
        dimension,
      ],
      "granularity": "month",
      "start_at": ds_dates["prior_month"],
      "end_at": ds_dates["month"],
      "metrics": [metric],
      "billing_center_ids": _.pluck(ds_toplevel_billing_centers, "id"),
      "summarized": true
    },
    headers: {
      "User-Agent": "RS Policies",
      "Api-Version": "1.0"
    },
    // Ignore status 400 which can arise if the dimension is newly created and not yet available via the costs API
    ignore_status: [400]
  }
EOS
end

datasource "ds_result_cost_dimensions" do
  run_script $js_result_cost_dimensions, $ds_rule_based_dimensions, $ds_tag_dimensions, $ds_bill_connects, $ds_cost_dimensions_costs
end

script "js_result_cost_dimensions", type: "javascript" do
  parameters "ds_rule_based_dimensions", "ds_tag_dimensions", "ds_bill_connects", "ds_cost_dimensions_costs"
  result "check_results"
  code <<-EOS
  function checkCosts(dimension_regex, costs) {
    // Filter the costs that match the dimension_regex
    var dimension_costs = _.filter(costs, function (cost) {
      return dimension_regex.test(cost.dimension);
    });
    // Get the total cost for the dimension
    var total_cost = _.reduce(dimension_costs, function (sum, cost) {
      return sum + cost.cost_nonamortized_unblended_adj;
    }, 0);
    // For each dimension cost, calculate the percentage of the total cost
    var dimension_cost_percentages = _.map(dimension_costs, function (cost) {
      return {
        "dimension": cost.dimension,
        "dimension_value": cost.dimension_value,
        "cost": cost.cost_nonamortized_unblended_adj,
        "percentage": (cost.cost_nonamortized_unblended_adj / total_cost) * 100
      };
    });
    return {
      "total_cost": total_cost,
      "dimension_cost_percentages": dimension_cost_percentages
    };
  }
  // Empty check results
  var check_results = [];
  // Get bill connects that match rege
  publicCloudRegex = /aws|azure|google|gce|gcp/;
  ds_bill_connects_filtered = _.filter(ds_bill_connects, function (bill_connect) {
    return publicCloudRegex.test(bill_connect.kind);
  });
  // Only check cost dimensions for cost allocation if there is at least 1 bill connect
  if (ds_bill_connects_filtered.length > 0) {
    // Check to see if there is at least one Tag Dimension
    if (!_.isArray(ds_tag_dimensions.values) || ds_tag_dimensions.values.length == 0) {
      check_results.push({
        "name": "First Tag Dimension",
        "severity": "high",
        "result": "fail",
        "details": "No Tag Dimension found."
      });
    } else {
      check_results.push({
        "name": "First Tag Dimension",
        "severity": "high",
        "result": "pass",
        "details": ds_tag_dimensions.values.length+" Tag Dimension(s) found."
      });
      // Check the costs for each Tag Dimension
      _.each(ds_tag_dimensions.values, function (dimension) {
        var costs = checkCosts(/tag_.*/, ds_cost_dimensions_costs);
        // Check that the cost.dimension_cost_percentages where dimension_value=None is less than 5%
        var none_cost = _.find(costs.dimension_cost_percentages, function (cost) {
          return cost.dimension_value == "None";
        });
        // If there is no cost for None, then it is 0%
        if (typeof none_cost == "undefined") {
          none_cost = {
            "dimension": dimension.name,
            "dimension_value": "None",
            "cost": 0,
            "percentage": 0
          };
        }
        // Disabling these for now.. don't agree we should encourage a % KPI that should have tag value
        // Tag Dimensions are not same as RBDs which we can theoretically allocate 100% of costs (even untaggable)
        // if (none_cost.percentage > 5) {
        //   check_results.push({
        //     "name": "Tag Dimension: "+dimension.name,
        //     "result": "fail",
        //     "details": "The None value for the "+dimension.name+" Tag Dimension is "+none_cost.percentage.toFixed(2)+"% of the total cost which is greater than the recommended threshold of 5%.  Recommend reviewing the None value for this Tag Dimension to identify."
        //   });
        // } else {
        //   check_results.push({
        //     "name": "Tag Dimension: "+dimension.name,
        //     "result": "pass",
        //     "details": "The None value for the "+dimension.name+" Tag Dimension is "+none_cost.percentage.toFixed(2)+"% of the total cost."
        //   });
        // }
      });
    }

    // Check to see if there is at least one Rule-Based Dimension
    if (!_.isArray(ds_rule_based_dimensions.values) || ds_rule_based_dimensions.values.length == 0) {
      check_results.push({
        "name": "First Rule-Based Dimension",
        "severity": "high",
        "result": "fail",
        "details": "No Rule-Based Dimension found."
      });
    } else {
      check_results.push({
        "name": "First Rule-Based Dimension",
        "severity": "high",
        "result": "pass",
        "details": ds_rule_based_dimensions.values.length+" Rule-Based Dimension(s) found."
      });
      // Check the costs for each Rule Based Dimension
      _.each(ds_rule_based_dimensions.values, function (dimension) {
        var costs = checkCosts(/rbd_.*/, ds_cost_dimensions_costs);
        // Check that the cost.dimension_cost_percentages where dimension_value=None is less than 5%
        var none_cost = _.find(costs.dimension_cost_percentages, function (cost) {
          return cost.dimension_value == "None";
        });
        // If there is no cost for None, then it is 0%
        if (typeof none_cost == "undefined") {
          none_cost = {
            "dimension": dimension.name,
            "dimension_value": "None",
            "cost": 0,
            "percentage": 0
          };
        }
        if (none_cost.percentage > 5) {
          check_results.push({
            "name": "Rule-Based Dimension: "+dimension.name+" Unallocated Percent of Total",
            "severity": "high",
            "result": "fail",
            "details": "The None value for the "+dimension.name+" Rule-Based Dimension is "+none_cost.percentage.toFixed(2)+"% of the total cost which is greater than the recommended threshold of 5%.  Recommend reviewing the None value for this Rule-Based Dimension to identify costs that can potentially be allocated with new rules."
          });
        } else {
          check_results.push({
            "name": "Rule-Based Dimension: "+dimension.name+" Unallocated Percent of Total",
            "severity": "high",
            "result": "pass",
            "details": "The None value for the "+dimension.name+" Tag Dimension is "+none_cost.percentage.toFixed(2)+"% of the total cost."
          });
        }
      });
    }
  }
EOS
end

datasource "ds_result_fail_service_account" do
  run_script $js_result_fail_service_account, $ds_service_accounts
end

script "js_result_fail_service_account", type: "javascript" do
  parameters "ds_service_accounts"
  result "results"
  code <<-EOS
  var results = {
      "action": ""
  };
  // Check to see if there is at least one Service Account
  if (ds_service_accounts.length == 0) {
    results = {
      "action": "Create a Service Account"
    };
  }
EOS
end

# Get Identity Providers
datasource "ds_idps" do
  request do
    auth $auth_flexera
    host val($ds_flexera_api_hosts, 'flexera')
    path join(["/iam/v1/orgs/", rs_org_id, "/idps"])
  end
end

datasource "ds_idp_ids" do
  run_script $js_idp_ids, $ds_idps
end

script "js_idp_ids", type: "javascript" do
  parameters "ds_idps"
  result "result"
  code <<-EOS
  result = _.pluck(ds_idps, "id");
EOS
end

# Get Domains for each Identity Provider
datasource "ds_idp_domains" do
  iterate $ds_idp_ids
  request do
    auth $auth_flexera
    host val($ds_flexera_api_hosts, 'flexera')
    path join(["/iam/v1/orgs/", rs_org_id, "/idps/", iter_item, "/domains"])
  end
end

# Get Login Policy
datasource "ds_login_policy" do
  request do
    auth $auth_flexera
    host val($ds_flexera_api_hosts, 'flexera')
    path join(["/iam/v1/orgs/", rs_org_id, "/login-policy"])
  end
end

datasource "ds_result_iam" do
  run_script $js_result_iam, $ds_idps, $ds_idp_domains, $ds_login_policy, $ds_flexera_api_hosts, rs_org_id
end

script "js_result_iam", type: "javascript" do
  parameters "ds_idps", "ds_idp_domains", "ds_login_policy", "ds_flexera_api_hosts", "rs_org_id"
  result "check_results"
  code <<-EOS
  check_results = [];
  // Check to see if there is at least one Identity Provider
  if (ds_idps.length == 0) {
    check_results.push({
      "name": "SSO: First Identity Provider",
      "severity": "medium",
      "result": "fail",
      "details": "No Identity Provider found.\\n\\nOnce you have configured single sign-on for your organization, your users can sign in to Flexera One using your identity provider instead of a username and password. When a user logs in with single sign-on, an audit entry in your master account captures the details.\\n\\nWhen configuring your identity provider with Flexera One, you can start with the [Flexera Docs > Setting Up an Identity Provider for Flexera One](https://docs.flexera.com/flexera/EN/Administration/CreateIDP.htm)."
    });
  } else {
    check_results.push({
      "name": "SSO: First Identity Provider",
      "severity": "medium",
      "result": "pass",
      "details": ds_idps.length+" Identity Provider(s) found."
    });
    // Check for First Identity Provider Domain
    if (ds_idp_domains.length == 0) {
      check_results.push({
        "name": "SSO: First Identity Provider Domain",
        "severity": "medium",
        "result": "fail",
        "details": "No Domain found for any Identity Provider.\\n\\nThe domain(s) that are added and verified determine which users can authenticate through your identity provider. The authenticating user’s email address is compared to the domains the identity provider has verified. If the email address matches one of the verified domains, the user is authenticated.\\n\\nTo remediate this, you can add and verify a domain in the UI [Administration > Identity Providers](https://"+ds_flexera_api_hosts.ui+"/orgs/"+rs_org_id+"/admin/identity-providers)\\n\\nFor more information, see [Flexera Docs > Adding a Domain](https://docs.flexera.com/flexera/EN/Administration/AddDomain.htm)"
      });
    } else {
      check_results.push({
        "name": "SSO: First Identity Provider Domain",
        "severity": "medium",
        "result": "pass",
        "details": ds_idp_domains.length+" Domain(s) found for at least one Identity Provider."
      });
      // Check for First Verified Identity Provider Domain
      var verified_domain = _.filter(ds_idp_domains, function (domain) {
        return typeof domain.verifiedAt == "string";
      });
      if (verified_domain.length == 0) {
        check_results.push({
          "name": "SSO: First Verified Identity Provider Domain",
          "severity": "medium",
          "result": "fail",
          "details": "No Domain found for any Identity Provider that has been verified. DNS is used to verify ownership of the domain.\\n\\nVerification is required for users with email addresses from the domain to authenticate through the configured identity provider into Flexera One.\\n\\nTo remediate this, you can verify a domain in the UI [Administration > Identity Providers](https://"+ds_flexera_api_hosts.ui+"/orgs/"+rs_org_id+"/admin/identity-providers)\\n\\nFor more information, see [Flexera Docs > Verifying a Domain With a TXT Record](https://docs.flexera.com/flexera/EN/Administration/VerifyDomain.htm)"
        });
      } else {
        check_results.push({
          "name": "SSO: First Verified Identity Provider Domain",
          "severity": "medium",
          "result": "pass",
          "details": verified_domain.length+" Domain(s) found for at least one Identity Provider that has been verified."
        });
        // Check for Just in Time Provisioning
        var jit_provisioning = _.filter(ds_idps, function (idp) {
          return idp.jitProvisioningEnabled == "true" || idp.jitProvisioningEnabled == true;
        });
        if (jit_provisioning.length == 0) {
          check_results.push({
            "name": "SSO: Enable Just in Time Provisioning",
            "severity": "medium",
            "result": "fail",
            "details": "Just in Time Provisioning is not enabled on any [Identity Provider(s)](https://"+ds_flexera_api_hosts.ui+"/orgs/"+rs_org_id+"/admin/identity-providers).\\n\\nOrganizations using Flexera One's SAML 2.0 single sign-on may enable Just-in-Time (JIT) provisioning for their Identity Providers (IdP) to automate user creation and Group Sync to synchronize groups from their IdP to Flexera One. The following sections describe how these features work.\\n\\nFor more information, see [Flexera Docs > Just-In-Time Provisioning](https://docs.flexera.com/flexera/EN/Administration/JITProvisioning.htm)"
          });
        } else {
          check_results.push({
            "name": "SSO: Enable Just in Time Provisioning",
            "severity": "medium",
            "result": "pass",
            "details": jit_provisioning.length+" Identity Provider(s) have Just in Time Provisioning enabled:\\n"+_.map(jit_provisioning, function (idp) {
              return " - "+idp.name;
            }).join("\\n")
          });
          // If they got this far, they are ready to enable "Mandatory SSO" / "Enforce SSO"
          // Check for Login Policy
          // if (typeof ds_login_policy.enforceSso == "boolean" && ds_login_policy.enforceSso ) {
          //   check_results.push({
          //     "name": "SSO: Enforce Single Sign-On",
          //     "severity": "medium",
          //     "result": "pass",
          //     "details": "Login Policy is configured to enforce Single Sign-On.  Access to this Org requires an identity in one of the configured and verified Identity Provider(s)](https://"+ds_flexera_api_hosts.ui+"/orgs/"+rs_org_id+"/admin/identity-providers)"
          //   });
          // } else {
          //   check_results.push({
          //     "name": "SSO: Enforce Single Sign-On",
          //     "severity": "medium",
          //     "result": "fail",
          //     "details": "Login Policy is not configured to enforce Single Sign-On.\\n\\nSingle Sign-On (SSO) enforcement is an organization-wide security setting available after identity provider (IdP) configuration is complete. When SSO enforcement is enabled, users accessing an org's resources must sign in through an identity provider in that org.\\n\\nBefore enforcing single sign-on, make sure you’re able to log in using your identity provider. If it’s not working, your organization will not be able to log in to Flexera One.\\n\\nTo remediate this, you can enable Single Sign-On in the UI [Administration > Identity Providers](https://"+ds_flexera_api_hosts.ui+"/orgs/"+rs_org_id+"/admin/identity-providers), button in the top right corner `'Single sign-on is not enforced'`\\n\\nFor more information, see [Flexera Docs > Enforcing Single Sign-On in Your Organization](https://docs.flexera.com/flexera/EN/Administration/EnforceSSO.htm)"
          //   });
          // }
        }
        // Check for Group Sync Policy
        var group_sync = _.filter(ds_idps, function (idp) {
          return idp.groupSyncPolicy != "NONE";
        });
        if (group_sync.length == 0) {
          check_results.push({
            "name": "SSO: Group Sync Policy Enabled",
            "severity": "medium",
            "result": "fail",
            "details": "Group Sync Policy is disabled for all Identity Providers. This can mitigate or prevent the need to manually manage user permissions within Flexera, and Flexera permissions can be managed centrally in the Identity Provider\\n\\nOrganizations with Just-in-Time (JIT) provisioning enabled may also enable group sync to automate permission management in Flexera One. When group sync is enabled, Flexera One accepts a list of group associations for the user sent by the IdP during login and adds/removes the user to those Flexera One groups as needed.\\n\\nFor more information, see [Flexera Docs > Group Sync](https://docs.flexera.com/flexera/EN/Administration/GroupSync.htm)"
          });
        } else {
          check_results.push({
            "name": "SSO: Group Sync Policy Enabled",
            "severity": "medium",
            "result": "pass",
            "details": group_sync.length+" Identity Provider(s) have Group Sync Policy enabled."
        });
        }
      }
    }
  }
EOS
end

datasource "ds_result" do
  run_script $js_result, $ds_result_service_account, $ds_result_bill_connects, $ds_result_applied_policy, $ds_check_specific_policy_templates, $ds_result_cost_dimensions, $ds_result_iam
end

script "js_result", type: "javascript" do
  parameters "ds_result_service_account", "ds_result_bill_connects", "ds_result_applied_policy", "ds_check_specific_policy_templates", "ds_result_cost_dimensions", "ds_result_iam"
  result "check_results"
  code <<-EOS
  // Combine all the results into a single array
  check_results = _.flatten([
    ds_result_service_account,
    ds_result_bill_connects,
    ds_result_applied_policy,
    ds_check_specific_policy_templates,
    ds_result_cost_dimensions,
    ds_result_iam,
  ]);
  // Sort the results by severity
  check_results = _.sortBy(check_results, function (check) {
    // Map severity to a number
    // Higher number, lower severity and item will be put towards end of list
    var severity = {
      "high": 1,
      "medium": 2,
      "low": 3,
    };
    return severity[check.severity];
  });
EOS
end

# datasource "ds_result_json" do
#   run_script $js_result_json, $ds_result
# end

# script "js_result_json", type: "javascript" do
#   parameters "ds_result"
#   result "result"
#   code <<-EOS
# result = JSON.stringify(ds_result);
# EOS
# end

datasource "ds_result_pass" do
  run_script $js_result_pass, $ds_result
end

script "js_result_pass", type: "javascript" do
  parameters "ds_result"
  result "results"
  code <<-EOS
  var results = _.filter(ds_result, function (check) {
    return check.result == "pass";
  });
EOS
end

datasource "ds_result_fail" do
  run_script $js_result_fail, $ds_result, $param_checks_exclude
end

script "js_result_fail", type: "javascript" do
  parameters "ds_result", "param_checks_exclude"
  result "results"
  code <<-EOS
  // Filter results to only include failed checks
  var results = _.filter(ds_result, function (check) {
    return check.result == "fail" ;
  });
  // Exclude checks from input parameter from the results
  results = _.filter(results, function (check) {
    return !_.contains(param_checks_exclude, check.name);
  });
EOS
end

###############################################################################
# Policy
###############################################################################

policy "pol_result" do
  # validate $ds_result_json do
  #   summary_template "Flexera Onboarding: JSON for Debugging"
  #   detail_template "{{ data }}"
  #   check eq(0, 1) # Always trigger
  # end

  validate $ds_result_pass do
    summary_template "Flexera Onboarding: Completed Summary"
    detail_template <<-EOS
# Completed List

{{ range data -}}
## {{ .name }}
{{ .details }}

{{ end -}}
EOS
    check eq(size(data), 0)
    escalate $esc_email
  end

  validate $ds_result_fail do
    summary_template "Flexera Onboarding: To Do Summary"
    detail_template <<-EOS
# To Do List

{{ range data -}}
## {{ .name }}
{{ .details }}

*Level: {{ .severity }}*

{{ end -}}
EOS
    check eq(size(data), 0)
    escalate $esc_email
  end

  validate $ds_result_fail_generally_recommended_templates do
    summary_template "Flexera Onboarding: Apply Recommended Policy Templates"
    detail_template <<-EOS
# Apply Recommended Policy Templates

The following recommended policy templates are not applied.  Please review and apply the recommended policy templates to increase visibility into potential optimization opportunities.
EOS
    check eq(size(data), 0)
    export do
      resource_level true # Enable actioning some, or all of the items
      field "id" do
        label "Policy Template Name"
        path "name"
      end
    end
    escalate $esc_apply_policy_templates
  end

  validate $ds_result_fail_service_account do
    summary_template "Flexera Onboarding: Create Service Account"
    detail_template <<-EOS
# Create Service Account

## Action Details

This action will do the needful to enable using a Service Account with Flexera Automation including:
  - Create a Service Account
  - Grant the Service Account permissions
  - Create a Client for the Service Account
  - Create a Flexera Automation Credential using Service Account Client ID + Service
EOS
    check ne(val(data, "action"), "Create a Service Account")
    export do
      # This should not need to be resource_level true
      # For some reason (UI bug?) it is not showing the action button in the UI when this is disabled.
      # Checked existing PTs, and all that have resource_level false only use "email" action which has automatic true and we potentially have not encountered a need for manual action that is not resource scoped.
      resource_level true
      field "id" do
        label "Action"
        path "action"
      end
    end
    escalate $esc_create_service_account
  end
end

###############################################################################
# Escalations
###############################################################################

escalation "esc_email" do
  automatic gt(size($param_email), 0)
  label "Send Email"
  description "Send incident email"
  email $param_email
end

escalation "esc_apply_policy_templates" do
  automatic false
  label "Apply Policy Templates"
  description "Apply the selected Policy Templates"
  # parameter "param_credential_auth_azure" do
  #   type "string"
  #   label "Azure Credential"
  #   description "Optional -- If no value provided, the first Azure credential found will be used.  The Credential Name or ID can be provided to specify the Azure Credential if there is more than one."
  #   default ""
  # end
  # parameter "param_credential_auth_aws" do
  #   type "string"
  #   label "AWS Credential"
  #   description "Optional -- If no value provided, the first AWS credential found will be used.  The Credential Name or ID can be provided to specify the Azure Credential if there is more than one."
  #   default ""
  # end
  # parameter "param_credential_auth_google" do
  #   type "string"
  #   label "Google Credential"
  #   description "Optional -- If no value provided, the first Google credential found will be used.  The Credential Name or ID can be provided to specify the Azure Credential if there is more than one."
  #   default ""
  # end
  # request_approval do
  #   label "Apply Policy Template"
  #   description "Approving this will apply the listed policy templates."
  # end
  run "create_applied_policies", data, rs_optima_host, rs_org_id, rs_project_id, rs_governance_host
end

escalation "esc_create_service_account" do
  automatic false
  label "Create Service Account"
  description "Create a Service Account"
  run "create_service_account", data, rs_optima_host, rs_org_id, rs_project_id, rs_governance_host
end

###############################################################################
# Cloud Workflow
###############################################################################

define hostname_lookup($rs_optima_host, $service) return $hostname do
  task_label("Starting lookup Flexera API Host: "+$rs_optima_host + " for service: " + $service)
  $host_table = {
    "api.optima.flexeraeng.com": {
      "ui": "app.flexera.com",
      "flexera": "api.flexera.com",
      "fsm": "api.fsm.flexeraeng.com",
      "login": "login.flexera.com"
    },
    "api.optima-eu.flexeraeng.com": {
      "ui": "app.flexera.eu",
      "flexera": "api.flexera.eu",
      "fsm": "api.fsm-eu.flexeraeng.com",
      "login": "login.flexera.eu"
    },
    "api.optima-apac.flexeraeng.com": {
      "ui": "app.flexera.au",
      "flexera": "api.flexera.au",
      "fsm": "api.fsm-apac.flexeraeng.com",
      "login": "login.flexera.au"
    }
  }
  $hostname = $host_table[$rs_optima_host][$service]
  task_label("Completed. Flexera API Host: "+$hostname)
end

# if name !=null
define create_applied_policies($data, $rs_optima_host, $rs_org_id, $rs_project_id, $rs_governance_host) return $responses do

  call hostname_lookup($rs_optima_host, "flexera") retrieve $$flexera_api_host

  $responses = []
  $$debug = []

  task_label("Get Published Templates")
  # This only needs to be done once
  $$published_templates = http_request(
    auth: $$auth_flexera,
    verb: "get",
    https: true,
    host: $$flexera_api_host,
    href: join(["/policy/v1/orgs/", $rs_org_id, "/published-templates"]),
    query_strings: {
      "view": "extended", # Extended view shows credentials
      "limit": "5000"
    }
  )
  $responses << $$published_templates
  # $$debug << to_json({
  #   "request": {
  #     "summary": "get https://"+join([$$flexera_api_host, "/policy/v1/orgs/", $rs_org_id, "/published-templates"])
  #   },
  #   "response": $$published_templates,
  #   "item": $item
  # })

  task_label("Get Credentials")
  $$credentials = http_request(
    auth: $$auth_flexera,
    verb: "get",
    https: true,
    host: $$flexera_api_host,
    href: join(["/cred/v2/projects/", $rs_project_id, "/credentials"])
  )
  $responses << $$credentials
  # $$debug << to_json({
  #   "request": {
  #     "summary": "get https://"+join([$$flexera_api_host, "/cred/v2/orgs/", $rs_org_id, "/credentials"])
  #   },
  #   "response": $$credentials,
  #   "item": $item
  # })

  # Loop through each item in the data
  $item_index = 0
  $item_total = size($data)
  foreach $item in $data on_error: handle_error() do
    # Increment the item index
    # Used for tracking task execution status
    $item_index = $item_index + 1
    $status = to_s("("+$item_index+"/"+$item_total+")")
    task_label("Processing item "+$status)
    $$debug << to_json($item) # Helpful for debugging

    # Get the Policy Template that matches the name + is "built in"
    $published_template = select($$published_templates["body"]["values"], { "name": $item["id"], "builtIn": true })
    if size($published_template) == 0
      raise "Published Template not found in Catalog: "+$item["id"]
    end
    # Select first item in array (there should only be one anyways)
    $published_template = first($published_template)
    task_label("Found Published Template: "+$published_template["name"])
    $$debug << to_json($published_template) # Helpful for debugging

    # For each credential on the PT, find the corresponding credential in the account
    $cred_payload = {}
    task_label("Loop through PT Credentials")
    foreach $pt_cred_key in keys($published_template["credentials"]) do
      $pt_cred = map($published_template, "credentials", $pt_cred_key)
      task_label("Processing PT Credential: "+$pt_cred["name"])
      # Select Provider value for this PT Credential
      $pt_cred_provider = ""
      # Loop through tags to identify the provider tag for the cred
      foreach $pt_cred_tag in $pt_cred["tags"] do
        # Check if tag is provider tag
        if $pt_cred_tag["key"] == "provider"
          # Use value to set pt_cred_provider
          $pt_cred_provider = $pt_cred_tag["value"]
        end
      end
      $$debug << "pt_cred_provider="+to_json($pt_cred_provider) # Helpful for debugging
      # Loop through Account Credentials
      foreach $account_cred in $$credentials["body"]["values"] do
        # Identify this Account Credential's Provider
        foreach $account_cred_tag in $account_cred["tags"] do
          # Check if the credential provider matches the PT credential provider
          if $account_cred_tag["key"] == "provider"
            # $$debug << $tag["value"]+" == "+$pt_cred_provider
            # Check if the credential provider matches the PT credential provider
            # OR if the PT credential provider is "databricks", we can also use a "azure_rm" credential provider
            # Downcase the account cred provider value and the PT cred provider value to ensure case-insensitive comparison
            if downcase($account_cred_tag["value"]) == downcase($pt_cred_provider) || ($pt_cred_provider == "databricks" && downcase($account_cred_tag["value"]) == "azure_rm")
              # $$debug << "Found credential for PT "+$published_template["name"]+". pt_cred="+to_json($pt_cred["name"])+" pt_cred_provider="+to_json($pt_cred_provider)+" account_cred="+to_json($account_cred["id"])
              $cred_name = $pt_cred["name"]
              $cred_value = $account_cred["id"]
              $cred_obj = { $cred_name: $cred_value }
              $cred_payload = $cred_payload + $cred_obj
            end
          end
        end
      end
    end
    $$debug << "cred_payload="+to_json($cred_payload) # Helpful for debugging

    # Create Applied Policy
    task_label($status+" Creating Applied Policy with Catalog Policy Template: "+$published_template["name"]+" ("+$published_template["id"])+")"
    $schedule = "FREQ="+upcase($published_template["defaultFrequency"])
    # Convert "15 MINUTES" defaultFrequency to RRULE "FREQ=MINUTELY;INTERVAL=15"
    if $schedule = "15 MINUTES"
      $schedule = "FREQ=MINUTELY;INTERVAL=15"
    end
    $body = {
      "name": $published_template["name"],
      "description": $published_template["shortDescription"],
      "templateRef": $published_template["ref"],
      "dryRun": false,
      "schedule": {
        "rrule": $schedule
      },
      "credentials": $cred_payload
    }
    $$debug << to_json($body) # Helpful for debugging
    $response = http_request(
      auth: $$auth_flexera,
      verb: "post",
      https: true,
      host: $$flexera_api_host,
      href: join(["/policy/v1/orgs/", $rs_org_id, "/projects/", $rs_project_id, "/applied-policies"]),
      body: $body
    )
    $responses << $response
    $$debug << to_json({
      "request": {
        "summary": "post https://"+join([$$flexera_api_host, "/policy/v1/orgs/", $rs_org_id, "/projects/", $rs_project_id, "/applied-policies"]),
        "body": $body
      },
      "response": $response,
      "item": $item
    })

    task_label("Check that the response is expected")
    if $response["code"] != 201
      raise "Failed to create Applied Policy: "+$published_template["name"]+". Response code: "+$response["code"]+". Response body: "+to_json($response["body"])
    end
  end

  # If we encountered any errors, use `raise` to mark the CWF process as errored
  if inspect($$errors) != "null"
    raise join($$errors, "\n")
  end

  # If we made it here, action completed successfully
  task_label("Action completed successfully")
end

define create_service_account($data, $rs_optima_host, $rs_org_id, $rs_project_id, $rs_governance_host) do
  if !$$debug
    $$debug = []
  end

  sub on_error: handle_error() do
    call hostname_lookup($rs_optima_host, "flexera") retrieve $$flexera_api_host

    ## Create Service Account
    $body = {
      "description": "Service Account for calling Flexera APIs from Flexera.  Created by Flexera Onboarding Policy Template Action",
      "name": "Service Account for Flexera Automation"
    }
    $href = join(["/iam/v1/orgs/", $rs_org_id, "/service-accounts"])
    $$debug << to_json($body) # Helpful for debugging
    $response = http_request(
      auth: $$auth_flexera,
      verb: "post",
      https: true,
      host: $$flexera_api_host,
      href: $href,
      body: $body
    )
    $$debug << to_json({
      "request": {
        "summary": "post https://"+join([$$flexera_api_host, $href]),
        "body": $body
      },
      "response": $response
    })
    task_label("Check that the response is expected")
    if $response["code"] != 201
      raise "Failed to create Service Account. Response code: "+$response["code"]+". Response body: "+to_json($response["body"])
    end

    ## Get Service Account ID from the response location header
    $service_account_id = last(split($response["headers"]["Location"], "/"))

    ## Grant Service Account `org_owner` Role
    ## org_owner is the highest role in the organization
    ## This is needed to validate Service Accounts, SSO, and other Org-scoped permissions
    $body = {
      "role": {
        "name": "org_owner"
      },
      "scope": {
        "ref": "ref::::iam:org:"+$rs_org_id
      },
      "subject": {
        "ref": "ref::::iam:service-account:"+$service_account_id
      }
    }
    $href = join(["/iam/v1/orgs/", $rs_org_id, "/access-rules/grant"])
    $$debug << to_json($body) # Helpful for debugging
    $response = http_request(
      auth: $$auth_flexera,
      verb: "put",
      https: true,
      host: $$flexera_api_host,
      href: $href,
      body: $body
    )
    $$debug << to_json({
      "request": {
        "summary": "put https://"+join([$$flexera_api_host, $href]),
        "body": $body
      },
      "response": $response
    })
    task_label("Check that the response is expected")
    if $response["code"] != 204
      raise "Failed to grant permissions. Response code: "+$response["code"]+". Response body: "+to_json($response["body"])
    end

    ## Create Service Account Client
    $href = join(["/iam/v1/orgs/", $rs_org_id, "/service-accounts/", $service_account_id, "/clients"])
    $$debug << to_json($body) # Helpful for debugging
    $response = http_request(
      auth: $$auth_flexera,
      verb: "post",
      https: true,
      host: $$flexera_api_host,
      href: $href
    )
    $$debug << to_json({
      "request": {
        "summary": "put https://"+join([$$flexera_api_host, $href]),
        "body": $body
      },
      "response": $response
    })
    task_label("Check that the response is expected")
    if $response["code"] != 201
      raise "Failed to create Service Account Client. Response code: "+$response["code"]+". Response body: "+to_json($response["body"])
    end

    ## Get clientId and clientSecret from the response body
    $client_id = $response["body"]["clientId"]
    $client_secret = $response["body"]["clientSecret"]

    ## Get Login API Host
    call hostname_lookup($rs_optima_host, "login") retrieve $login_api_host

    ## Create a Flexera Automation OAuth2 Credential
    $body = {
      "clientCredentialsParams": {
        "clientId": $client_id,
        "clientSecret": $client_secret
      },
      "description": "Service Account for calling Flexera APIs from Flexera.  Created by Flexera Onboarding Policy Template Action",
      "grantType": "client_credentials",
      "name": "Flexera Service Account",
      "tags": [
        {
          "key": "provider",
          "value": "flexera"
        }
      ],
      "tokenUrl": "https://"+$login_api_host+"/oidc/token"
    }
    $href = join(["/cred/v2/projects/", $rs_project_id, "/credentials/oauth2/Flexera_Service_Account_"+$service_account_id])
    $$debug << to_json($body) # Helpful for debugging
    $response = http_request(
      auth: $$auth_flexera,
      verb: "put",
      https: true,
      host: $$flexera_api_host,
      href: $href,
      body: $body
    )
    $$debug << to_json({
      "request": {
        "summary": "put https://"+join([$$flexera_api_host, $href]),
        "body": $body
      },
      "response": $response
    })
    task_label("Check that the response is expected")
    if $response["code"] != 201
      raise "Failed to create Flexera Automation OAuth2 Credential. Response code: "+$response["code"]+". Response body: "+to_json($response["body"])
    end
  end # end sub do on_error

  # If we encountered any errors, use `raise` to mark the CWF process as errored
  if inspect($$errors) != "null"
    raise join($$errors, "\n")
  end

  # If we made it here, action completed successfully
  task_label("Action completed successfully")
end

# CWF function to handle errors
define handle_error() do
  if !$$errors
    $$errors = []
  end
  $$errors << $_error["type"] + ": " + $_error["message"]
  # We check for errors at the end, and raise them all together
  # Skip errors handled by this definition
  $_error_behavior = "skip"
end
