name "AWS Unused IP Addresses Meta Parent Load Testing"
rs_pt_ver 20180301
type "policy"
short_description "Updated version of a policy which tracks AWS bucket info"
long_description "Applied Bucket Tracker updated to delete itself if applied as a meta child policy and the meta parent policy has terminated"
severity "low"
category "Cost"
tenancy "single"
default_frequency "15 minutes"
info(
  version: "1.0",
)

##############################################################################
# Parameters
##############################################################################

parameter "param_rbd_name" do
  type "string"
  label "Rule Based Dimension Filter Name"
  description "The name of the filter used to determine which AWS accounts the policy should be run in. During each run this policy will use this along with the filter value to match with Billing Center accounts who have both values set."
  default "rbd_meta_policy_test"
end

parameter "param_rbd_value" do
  type "string"
  label "Rule Based Dimension Filter Value"
  description "The valuie of the filter used to determine which AWS accounts the policy should be run in. During each run this policy will use this along with the name value to match with Billing Center accounts who have both values set."
  default "staging"
end


parameter "param_allowed_regions" do
  type "list"
  label "Allowed Regions"
  allowed_pattern /^([a-zA-Z-_]+-[a-zA-Z0-9-_]+-[0-9-_]+,*|)+$/
  description "A list of allowed regions. See the README for more details"
  default ["us-west-2", "us-east-2"]
end

parameter "param_exclude_tags" do
  type "list"
  label "Exclusion Tags"
  description "A list of AWS tags to ignore Elastic IPs. Format: Key=Value"
end

# Excluding this as we don't want the children to email.
# I also expect a lot of noise when the parent starts up and is running every 15 minutes applying policies
# and creating new incidents for each run until it runs out of accounts.
# parameter "param_email" do
#   type "list"
#   label "Email addresses"
#   description "Email addresses of the recipients you wish to notify when new incidents are created"
# end

# Don't need this from the user
# parameter "param_aws_account_number" do
#   type "string"
#   label "Account Number"
#   description "The account number for AWS STS Cross Account Roles."
#   default ""
# end

# Allowing this for now, we can decide if we want to disable automatic destructive actions at scale
parameter "param_automatic_action" do
  type "list"
  label "Automatic Actions"
  description "When this value is set, this policy will automatically take the selected action(s)"
  allowed_values ["Delete Unused IPs"]
end

parameter "param_log_to_cm_audit_entries" do
  type "string"
  label "Log to CM Audit Entries"
  description "Boolean for whether or not to log any debugging information from actions to CM Audit Entries, this should be left set to No on Flexera EU"
  default "No"
  allowed_values "Yes", "No"
end

parameter "param_number_of_children" do
  type "number"
  label "Number of Child Policies to Create"
  description "The number of child policies this should create."
  default 50
end

###############################################################################
# Authentication
###############################################################################

credentials "auth_aws" do
  schemes "aws","aws_sts"
  label "AWS"
  description "Select the AWS Cloud Credential from the list."
  tags "provider=aws"
end

auth "auth_rs", type: "rightscale"

###############################################################################
# Datasources
###############################################################################

# Get Policy itself
datasource "ds_self_policy_information" do
  request do
    auth $auth_rs
    host rs_governance_host
    path join(["/api/governance/projects/", rs_project_id, "/applied_policies/", policy_id])
    header "Api-Version", "1.0"
  end
  result do
    encoding "json"
    field "creator_id", jmes_path(response, "created_by.id")
    field "credentials", jmes_path(response, "credentials")
    field "options", jmes_path(response, "options")
  end
end

datasource "ds_format_self" do
  run_script $js_format_self, $ds_self_policy_information
end

script "js_format_self", type: "javascript" do
  parameters "unformatted"
  result "formatted"
  code <<-EOS
  formatted={
    "creator_id": unformatted["creator_id"],
    "credentials": unformatted["credentials"],
    "options": {
      "param_email": [],
      "param_allowed_regions": [],
      "param_exclude_tags": [],
      "param_automatic_action": [],
      "param_log_to_cm_audit_entries": "No"
    }
  }
  for (x=0;x<unformatted.options.length; x++) {
    if (formatted["options"][unformatted.options[x]["name"]] != undefined) {
      formatted["options"][unformatted.options[x]["name"]] = unformatted.options[x]["value"]
    }
  }
  EOS
end

# policy_created_by_id
# Get the Billing Center IDs the customer has access to
datasource "ds_get_billing_centers" do
  request do
    auth $auth_rs
    host rs_optima_host
    path join(["/analytics/users/", val($ds_format_self, "creator_id"), "/orgs/", rs_org_id, "/billing_centers"])
    header "Api-Version", "0.1"
  end
end

script "js_make_billing_center_request", type: "javascript" do
  parameters "rs_org_id", "rs_optima_host", "billing_centers_unformatted", "param_rbd_name", "param_rbd_value"
  result "request"
  code <<-EOS

  billing_centers_formatted = []

  for (x=0; x< billing_centers_unformatted.length; x++) {
    billing_centers_formatted.push(billing_centers_unformatted[x]["id"])
  }

  finish = new Date()
  finishFormatted = finish.toJSON().split("T")[0]
  start = new Date()
  start.setDate(start.getDate() - 30)
  startFormatted = start.toJSON().split("T")[0]

  var body = {
    "dimensions":["vendor_account", "vendor_account_name", param_rbd_name],
    "granularity":"day",
    "start_at": startFormatted,
    "end_at": finishFormatted,
    "metrics":["cost_amortized_unblended_adj"],
    "billing_center_ids": billing_centers_formatted,
    "filter":{"dimension":param_rbd_name, "type":"equal", "value":param_rbd_value},
    "summarized": true
  }
  var request = {
    auth:  'auth_rs',
    host:  rs_optima_host,
    scheme: 'https',
    verb: 'POST',
    path:  "/bill-analysis/orgs/"+ rs_org_id + "/costs/aggregated",
    headers: {
      "API-Version": "1.0",
      "Content-Type":"application/json"
    },
    body: JSON.stringify(body)
  }
  EOS
end

# Get the AWS acounts
datasource "ds_get_aws_accounts" do
  request do
    run_script $js_make_billing_center_request, rs_org_id, rs_optima_host, $ds_get_billing_centers, $param_rbd_name, $param_rbd_value
  end
  result do
    encoding "json"
    collect jmes_path(response,"rows[*]") do
      field "aws_account_id", jmes_path(col_item,"dimensions.vendor_account")
      field "aws_account_name", jmes_path(col_item,"dimensions.vendor_account_name")
    end
  end
end

# Get Child policies
datasource "ds_get_existing_policies" do
  request do
    auth $auth_rs
    host rs_governance_host
    path join(["/api/governance/projects/", rs_project_id, "/applied_policies"])
    header "Api-Version", "1.0"
    query "meta_parent_policy_id", policy_id
  end
  result do
    collect jq(response, '.items[]?') do
      field "name", jq(col_item, ".name")
      field "applied_policy_id", jq(col_item, ".id")
      field "options", jq(col_item, ".options")
      field "updated_at", jq(col_item, ".updated_at")
      field "status", jq(col_item, ".status")
    end
  end
end

# Get Child policies incidents
datasource "ds_get_existing_policies_incidents" do
  request do
    auth $auth_rs
    host rs_governance_host
    path join(["/api/governance/projects/", rs_project_id, "/incidents"])
    header "Api-Version", "1.0"
    query "meta_parent_policy_id", policy_id
  end
  result do
    collect jq(response, '.items[]?') do
      field "incident_id", jq(col_item, ".id")
      field "applied_policy_id", jq(col_item, ".applied_policy.id")
      field "state", jq(col_item, ".state")
      field "violation_data_count", jq(col_item, ".violation_data_count")
      field "updated_at", jq(col_item, ".updated_at")
    end
  end
end

datasource "ds_format_incidents" do
  run_script $js_format_existing_policies_incidents, $ds_get_existing_policies_incidents
end

script "js_format_existing_policies_incidents", type: "javascript" do
  parameters "unformatted"
  result "formatted"
  code <<-EOS
  formatted={}
  for (x=0;x<unformatted.length; x++) {
    current = unformatted[x]
    formatted[current.applied_policy_id] = {incident_id: current.incident_id, state: current.state, violation_data_count: current.violation_data_count, updated_at: current.updated_at}
  }
  EOS
end

datasource "ds_format_existing_policies" do
  run_script $js_format_existing_policies, $ds_get_existing_policies, $ds_format_incidents
end

# format
# duplicates logic should compare updated at
# we can validate update here when destructring the existing policy options, don't need updated at
# format options

# for (x=0; x<param_total_accounts; x++)
# ds_format_aws_accounts
# aws_account_id = "733834855010",
# aws_account_name = "usage-monitoring-staging",
# iterator = x
#
script "js_format_existing_policies", type: "javascript" do
  parameters "unformatted", "incidents"
  result "result"
  code <<-EOS

  result = {}
  formatted = {}
  duplicates = []
  tracking = {}

  for (x=0; x<unformatted.length; x++) {
    options= {
      "param_email": [],
      "param_allowed_regions": [],
      "param_exclude_tags": [],
      "param_automatic_action": [],
      "param_log_to_cm_audit_entries": "No",
      "param_aws_account_number": "",
      "param_versioning": 0
    }
    for (y=0;y<unformatted[x].options.length; y++) {
      if (options[unformatted[x].options[y]["name"]] != undefined) {
        options[unformatted[x].options[y]["name"]] = unformatted[x].options[y]["value"]
      }
    }
    child_id=options["param_versioning"]
    if (formatted[child_id] == undefined) {
      formatted[child_id] = {
        "applied_policy_id":unformatted[x]["applied_policy_id"],
        "applied_policy_name":unformatted[x]["name"],
        "status":unformatted[x]["status"],
        "updated_at":unformatted[x]["updated_at"],
        "incident": incidents[unformatted[x]["applied_policy_id"]],
        "options": options
      }
      tracking[child_id] = false
    } else {
      current = formatted[child_id]

      currDate = new Date(current.updated_at)
      newDate = new Date(unformatted[x].updated_at)

      if (currDate > newDate) {
        duplicates.push({
          "applied_policy_id":unformatted[x]["applied_policy_id"],
          "applied_policy_name":unformatted[x]["name"],
          "status":unformatted[x]["status"],
          "updated_at":unformatted[x]["updated_at"],
          "incident": incidents[unformatted[x]["applied_policy_id"]]
        })
      } else {
        duplicates.push({
          "applied_policy_id":current["applied_policy_id"],
          "applied_policy_name":current["applied_policy_name"],
          "status":current["status"],
          "updated_at":current["updated_at"],
          "incident": current["incident"]
        })
        formatted[child_id] = {
          "applied_policy_id":unformatted[x]["applied_policy_id"],
          "applied_policy_name":unformatted[x]["name"],
          "status":unformatted[x]["status"],
          "updated_at":unformatted[x]["updated_at"],
          "incident": incidents[unformatted[x]["applied_policy_id"]],
          "options": options
        }

      }
    }
  }

  result.formatted=formatted
  result.duplicates=duplicates
  result.tracking=tracking
  EOS
end

datasource "ds_take_in_parameters" do
  run_script $js_take_in_parameters, $ds_get_aws_accounts, $ds_format_self, $ds_format_existing_policies, policy_id, f1_app_host, rs_org_id, rs_project_id, $param_number_of_children
end

# hardcode template href with id from catalog
# catalog policies show in customer's published templates with their org id
# "template_href": "/api/governance/orgs/" + rs_org_id + "/published_templates/62618616e3dff80001572bf0"
# update logic: the only reason we're going to update the child policies for is changes to options
# and only some options, email is always blank and aws_account_id is tied to the idenity of each policy, so: new account creation, removal of account: termination
# param_automatic_action is a list with only one action, unless the person is applying using an API and putting the same value multiple times this should either be a length of 0 or 1
# param_log_to_cm_audit_entries is a String of Yes or No
# param_exclude_tags and param_allowed_regions are arrays. I'm doing an update on the order changing but the values remaining the same.
# If we only want to do an update on the values changing we could sort before doing the equality check.
script "js_take_in_parameters", type: "javascript" do
  parameters "aws_account_ids", "parent_policy", "existing_policies", "meta_parent_policy_id", "f1_app_host", "rs_org_id", "rs_project_id", "param_number_of_children"
  result "grid_and_cwf"
  code <<-EOS

  max_actions = 20

  grid_and_cwf={grid:[], to_create:[], to_update:[], to_delete:[]}

  should_keep = existing_policies.tracking

  function add_to_grid(ep, action) {
    policy_status={
      "policy_name": ep["applied_policy_name"],
      "policy_link": "https://" + f1_app_host + "/orgs/" + rs_org_id + "/policy/projects/" + rs_project_id + "/applied-policies/" + ep["applied_policy_id"],
      "meta_policy_status": action,
      "policy_status": ep["status"],
      "policy_last_update": ep["updated_at"],
    }
    if (ep.incident != null) {
      policy_status["incident_link"] = "https://" + f1_app_host + "/orgs/" + rs_org_id + "/policy/projects/" + rs_project_id + "/incidents/" + ep.incident.incident_id
      policy_status["incident_state"] = ep.incident.state
      policy_status["incident_violation_data_count"] = ep.incident.violation_data_count
      policy_status["incident_last_update"] = ep.incident.updated_at
    }
    grid_and_cwf.grid.push(policy_status)
  }

  for (x=0; x<existing_policies.duplicates.length; x++) {
    if (grid_and_cwf.to_delete.length < max_actions) {
      grid_and_cwf.to_delete.push({"id":existing_policies.duplicates[x]["applied_policy_id"], "name": existing_policies.duplicates[x]["applied_policy_name"]})
      add_to_grid(existing_policies.duplicates[x], "terminating")
    } else {
      add_to_grid(existing_policies.duplicates[x], "to be terminated")
    }
  }


  for (x=0; x<param_number_of_children; x++) {
    if (existing_policies.formatted[x] == undefined) {
      name = "Bucket Tracking for: " + x
      options = [
        {
          "name": "param_email",
          "value": parent_policy.options.param_email
        },
        {
          "name": "param_allowed_regions",
          "value": parent_policy.options.param_allowed_regions
        },
        {
          "name": "param_exclude_tags",
          "value": parent_policy.options.param_exclude_tags
        },
        {
          "name": "param_automatic_action",
          "value": parent_policy.options.param_automatic_action
        },
        {
          "name": "param_log_to_cm_audit_entries",
          "value": parent_policy.options.param_log_to_cm_audit_entries
        },
        {
          "name": "param_aws_account_number",
          "value": ""
        },
        {
          "name": "param_versioning",
          "value": x
        },
      ]
      if (grid_and_cwf.to_create.length < max_actions) {
        grid_and_cwf.to_create.push({
          "name" : name,
          "credentials" : parent_policy.credentials,
          "options" : options,
          "frequency" : "daily",
          "meta_parent_policy_id": meta_parent_policy_id,
          "template_href": "/api/governance/projects/60073/policy_templates/6285ee12d1de560001b5615c",
        })
        policy_status={
          "policy_name": name,
          "meta_policy_status": "creating policy",
          "policy_status": "",
          "policy_last_update": "",
        }
        grid_and_cwf.grid.push(policy_status)
      } else {
        policy_status={
          "policy_name": name,
          "meta_policy_status": "policy to be created",
          "policy_status": "",
          "policy_last_update": "",
        }
        grid_and_cwf.grid.push(policy_status)
      }
    } else {
      should_keep[x]= true
      should_update = false
      options = [
        {
          "name": "param_email",
          "value": parent_policy.options.param_email
        },
        {
          "name": "param_aws_account_number",
          "value": ""
        },
        {
          "name": "param_automatic_action",
          "value": parent_policy.options.param_automatic_action
        },
        {
          "name": "param_log_to_cm_audit_entries",
          "value": parent_policy.options.param_log_to_cm_audit_entries
        },
        {
          "name": "param_allowed_regions",
          "value": parent_policy.options.param_allowed_regions
        },
        {
          "name": "param_exclude_tags",
          "value": parent_policy.options.param_exclude_tags
        },
        {
          "name": "param_versioning",
          "value": x
        },
      ]

      if (parent_policy.options.param_automatic_action.length != existing_policies["formatted"][x]["options"]["param_automatic_action"].length) {
        should_update = true
      }

      if (parent_policy.options.param_log_to_cm_audit_entries != existing_policies["formatted"][x]["options"]["param_log_to_cm_audit_entries"]) {
        should_update = true
      }

      if (!_.isEqual(parent_policy.options.param_allowed_regions, existing_policies["formatted"][x]["options"]["param_allowed_regions"])) {
        should_update = true
      }

      if (!_.isEqual(parent_policy.options.param_exclude_tags, existing_policies["formatted"][x]["options"]["param_exclude_tags"])) {
        should_update = true
      }

      if (should_update) {
        if (grid_and_cwf.to_update.length < max_actions) {
          add_to_grid(existing_policies.formatted[x], "updating")
          name = existing_policies.formatted[x].applied_policy_name
          grid_and_cwf.to_update.push({
            "applied_policy_id": existing_policies.formatted[x].applied_policy_id,
            "name" : name,
            "credentials" : parent_policy.credentials,
            "options" : options,
            "frequency" : "daily",
          })
        } else {
          add_to_grid(existing_policies.formatted[x], "to be updated")
        }
      } else {
        add_to_grid(existing_policies.formatted[x], "running")
      }
    }
  }

  for (key in should_keep) {
    if (!should_keep[key]) {
      if (grid_and_cwf.to_delete.length < max_actions) {
        grid_and_cwf.to_delete.push({"id":existing_policies.formatted[key].applied_policy_id, "name": existing_policies.formatted[key].applied_policy_name})
        add_to_grid(existing_policies.formatted[key], "terminating")
      } else {
        add_to_grid(existing_policies.formatted[key], "to be terminated")
      }
    }
  }

  EOS
end

datasource "ds_only_grid" do
  run_script $js_only_grid, $ds_take_in_parameters
end

script "js_only_grid", type: "javascript" do
  parameters "results"
  result "only_grid"
  code <<-EOS
    only_grid = results.grid
  EOS
end

datasource "ds_to_create" do
  run_script $js_only_create, $ds_take_in_parameters
end

script "js_only_create", type: "javascript" do
  parameters "results"
  result "only_create"
  code <<-EOS
    only_create = results.to_create
  EOS
end

datasource "ds_to_update" do
  run_script $js_only_update, $ds_take_in_parameters
end

script "js_only_update", type: "javascript" do
  parameters "results"
  result "only_update"
  code <<-EOS
    only_update = results.to_update
  EOS
end

datasource "ds_to_delete" do
  run_script $js_only_delete, $ds_take_in_parameters
end

script "js_only_delete", type: "javascript" do
  parameters "results"
  result "only_delete"
  code <<-EOS
    only_delete = results.to_delete
  EOS
end


# Summary and a conditional incident which will show up if any policy is being applied, updated or deleted.
# Minimum of 1 incident, max of four
# Could swap the summary to only showing running
# Could also just have one incident and use meta_status to determine which esclation happens
policy "policy_scheduled_report" do
  validate $ds_only_grid do
    summary_template "Status of Meta Child Policies"
    detail_template <<-EOS
The current status of this Policy's Meta Child Policies:

| Appplied Policy | Meta Child Policy Status | Policy Status | Policy Last Update | Incident | Incident Status | Violation Count | Incident Last Update |
| --------------- | ------------------------ | ------------- | ------------------ | -------- | --------------- | --------------- | -------------------- |
{{ range data -}}
| [{{ .policy_name }}]({{ .policy_link }}) | {{ .meta_policy_status }} | {{ .policy_status }} | {{ .policy_last_update }} | [Incident]({{ .incident_link }}) | {{ .incident_state }} | {{ .incident_violation_data_count }} | {{ .incident_last_update }} |
{{ end -}}
EOS
    check false
  end
  validate $ds_to_create do
    summary_template "Policies being created"
    detail_template <<-EOS
    Policies Being Created:

    | Appplied Policy |
    | --------------- |
    {{ range data -}}
    | {{ .name }} |
    {{ end -}}
    EOS
    escalate $create_policies
    check eq(size(data),0)
  end
  validate $ds_to_update do
    summary_template "Policies being updated"
    detail_template <<-EOS
    Policies Being Updated:

    | Appplied Policy |
    | --------------- |
    {{ range data -}}
    | {{ .name }} |
    {{ end -}}
    EOS
    escalate $update_policies
    check eq(size(data),0)
  end
  validate $ds_to_delete do
    summary_template "Policies being deleted"
    detail_template <<-EOS
    Policies being Deleted:

    | Appplied Policy |
    | --------------- |
    {{ range data -}}
    | {{ .name }} |
    {{ end -}}
    EOS
    escalate $delete_policies
    check eq(size(data),0)
  end
end

escalation "create_policies" do
  run "create_applied_policies", data, rs_governance_host, rs_project_id
end

# if name !=null
define create_applied_policies($data, $governance_host, $rs_project_id) return $responses do
  $responses = []
  foreach $item in $data do
    $response = http_request(
      verb: "post",
      https: true,
      host: $governance_host,
      href: join(["/api/governance/projects/", $rs_project_id, "/applied_policies"]),
      headers: { "Api-Version": "1.0" },
      body: {
        "name": $item["name"],
        "template_href": $item["template_href"],
        "frequency": $item["frequency"],
        "options": $item["options"],
        "credentials": $item["credentials"],
        "meta_parent_policy_id": $item["meta_parent_policy_id"]
      }
    )
    $responses << $response
  end
end

escalation "update_policies" do
  run "update_applied_policies", data, rs_governance_host, rs_project_id
end

define update_applied_policies($data, $governance_host, $rs_project_id) return $responses do
  $responses = []
  foreach $item in $data do
    $response = http_request(
      verb: "patch",
      https: true,
      host: $governance_host,
      href: join(["/api/governance/projects/", $rs_project_id, "/applied_policies/", $item["applied_policy_id"]]),
      headers: { "Api-Version": "1.0" },
      body: {
        "options": $item["options"]
      }
    )
    $responses << $response
  end
end


escalation "delete_policies" do
  run "delete_applied_policies", data, rs_governance_host, rs_project_id
end

define delete_applied_policies($data, $governance_host, $rs_project_id) return $responses do
  $responses = []
  foreach $item in $data do
    $response = http_request(
      verb: "delete",
      https: true,
      host: $governance_host,
      href: join(["/api/governance/projects/", $rs_project_id, "/applied_policies/", $item["id"]]),
      headers: { "Api-Version": "1.0" }
    )
    $responses << $response
  end
end

