name "Azure Untagged Resources"
rs_pt_ver 20180301
type "policy"
short_description "Find all Azure resources missing any of the user provided tags with the option to update the resources with the missing tags. See the [README](https://github.com/flexera-public/policy_templates/tree/master/compliance/azure/azure_untagged_resources) and [docs.flexera.com/flexera/EN/Automation](https://docs.flexera.com/flexera/EN/Automation/AutomationGS.htm) to learn more."
long_description ""
category "Compliance"
severity "low"
default_frequency "weekly"
info(
  version: "2.13",
  provider: "Azure",
  service: "",
  policy_set: "Untagged Resources"
)

###############################################################################
# User inputs
###############################################################################

parameter "param_email" do
  type "list"
  label "Email addresses to notify"
  description "Email addresses of the recipients you wish to notify when new incidents are created"
end

parameter "param_azure_endpoint" do
  type "string"
  label "Azure Endpoint"
  allowed_values "management.azure.com", "management.chinacloudapi.cn"
  default "management.azure.com"
end

parameter "param_subscription_allowed_list" do
  label "Subscription Allowed List"
  type "list"
  description "Allowed Subscriptions, if empty, all subscriptions will be checked"
end

parameter "param_tags_to_check" do
  type "list"
  label "Tag Keys"
  category "Azure"
  allowed_pattern /\S/
  description "List of tags keys e.g., 'Environment' to find resources which are not tagged by given inputs"
  constraint_description <<-EOS
    This is a mandatory field.
  EOS
end

###############################################################################
# Authentication
###############################################################################

credentials "azure_auth" do
  schemes "oauth2"
  label "Azure"
  description "Select the Azure Resource Manager Credential from the list."
  tags "provider=azure_rm"
end

###############################################################################
# Pagination
###############################################################################

pagination "azure_pagination" do
  get_page_marker do
    body_path "nextLink"
  end
  set_page_marker do
    uri true
  end
end

###############################################################################
# Datasources & Scripts
###############################################################################

#GET LIST OF AZURE SUBSCRIPTIONS
datasource "ds_subscriptions" do
  request do
    auth $azure_auth
    pagination $azure_pagination
    host $param_azure_endpoint
    path "/subscriptions/"
    query "api-version","2018-06-01"
    header "User-Agent", "RS Policies"
  end
  result do
    encoding "json"
    collect jmes_path(response, "value[*]") do
      field "subscriptionId", jmes_path(col_item,"subscriptionId")
      field "subscriptionName", jmes_path(col_item,"displayName")
    end
  end
end

#FILTER SUBSCRIPTIONS BY 'SUBSCRIPTION WHITELIST' PARAMETERS
datasource "ds_filtered_subscriptions" do
  run_script $js_filtered_subscriptions, $ds_subscriptions, $param_subscription_allowed_list
end

script "js_filtered_subscriptions", type: "javascript" do
  parameters "ds_subscriptions", "param_subscription_allowed_list"
  result "results"
  code <<-EOS
  var results = []
  if ( param_subscription_allowed_list.length != 0){
    results = []
    _.each(param_subscription_allowed_list, function(sub){
      var found = _.find(ds_subscriptions, function(item){
        return item.subscriptionId == sub || item.subscriptionName.toLowerCase() == sub.toLowerCase();
      })
      results.push(found)
    })
  } else {
    results = ds_subscriptions
  }
  EOS
end

#GET LIST OF ALL RESOURCES FOR EACH SUBSCRIPTION
datasource "ds_azure_resources" do
  iterate $ds_filtered_subscriptions
  request do
    auth $azure_auth
    pagination $azure_pagination
    host $param_azure_endpoint
    path join(["/subscriptions/", val(iter_item,"subscriptionId"), "/resources"])
    query "api-version","2020-06-01"
    header "User-Agent", "RS Policies"
    # Ignore status 400, 403, and 404 which can be returned in certain (legacy) types of Azure Subscriptions
    ignore_status [400,403,404]
  end
  result do
    encoding "json"
    collect jmes_path(response, "value[*]") do
      field "subscriptionId", val(iter_item,"subscriptionId")
      field "subscriptionName", val(iter_item,"subscriptionName")
      field "id", jmes_path(col_item,"id")
      field "resourceGroup", get(4,split(jmes_path(col_item,"id"),'/'))
      field "namespace", get(6,split(jmes_path(col_item,"id"),'/'))
      field "region", jmes_path(col_item,"location")
      field "name", jmes_path(col_item,"name")
      field "tags", jmes_path(col_item,"tags")
      field "type", jmes_path(col_item,"type")
    end
  end
end

#GET AZURE TAG SUPPORT DATA FROM GITHUB
# See also: https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/tag-support
# and the original CSV: https://raw.githubusercontent.com/tfitzmac/resource-capabilities/master/tag-support.csv
datasource "ds_tag_support" do
  request do
    host "raw.githubusercontent.com"
    path "/flexera/policy_templates/master/data/azure/tag-support.csv"
  end
  result do
    encoding "text"
  end
end

datasource "ds_parsed_tag_support" do
  run_script $js_parse_tag_support, $ds_tag_support
end

script "js_parse_tag_support", type: "javascript" do
  parameters "ds_tag_support"
  result "result"
  code <<-EOS
    var result = {};
    var rows = ds_tag_support.split(/\\r?\\n/);
    // Skip headers
    rows.shift();
    _.each(rows, function(row){
      var fields = row.split(',');
      result[(fields[0]+"/"+fields[1]).toLowerCase()] = fields[2];
    });
  EOS
end

#FILTER RESOURCES BY 'TAGS TO CHECK' PARAMETER
datasource "ds_filtered_resources" do
  run_script $js_filter_resources, $ds_azure_resources, $param_tags_to_check, $ds_parsed_tag_support
end

script "js_filter_resources", type: "javascript" do
  parameters "ds_azure_resources", "param_tags_to_check", "ds_parsed_tag_support"
  result "result"
  code <<-EOS
  result=[];

  //Convert Tag Objects to Tag Arrays for each Resource
  _.each(ds_azure_resources, function(resource){

    //Create variable for original tag object
    var tags = resource.tags
    console.log("Original Tags:", tags)     //for reference

    //Overwrite orginal tag object with empty tag array
    resource["tags"] = []
    if (!( tags == null || tags == undefined )) {
      var tag_keys = _.keys(tags)          //list of tag keys
      _.each(tag_keys, function(key){
        resource.tags.push({
          "tagKey": key,
          "tagValue": tags[key]
        })
      })
    }
    console.log("Resource Name: " + resource.name, "Resource Tags:", resource.tags)     //for reference
  })

  //For each Resource in Resource List
  _.each(ds_azure_resources, function(resource){

    //Create a field for Missing tags
    resource["missingTagKeys"] = []
    resource["missingTagValues"] = []

    //For each Tag in Param Tag List
    _.each(param_tags_to_check, function(param){
      // Find Param Tag Key in Resource Tag Array
      current_tag = _.find(resource.tags, function(tag){ return tag.tagKey == param })
      // If Tag Key does not exist for Resource, create Missing Tag field and set to True
      if ( current_tag == undefined || current_tag == null) {
        resource["isMissingTagKey"] = true
        resource.missingTagKeys.push(param)
      }
      // Otherwise, if Tag Key does exist...
      else {
        // and if Tag Value is empty, create Missing Tag field and set to True
        if ( current_tag.tagValue == "" || current_tag.tagValue == null ) {
          resource["isMissingTagValue"] = true
          resource.missingTagValues.push(param)
        }
      }
    })
  })

  //Filter out all tags where isMissingTag != true
  filtered_resources = _.filter(ds_azure_resources, function(resource){ return resource.isMissingTagKey == true || resource.isMissingTagValue == true })


  _.each(filtered_resources, function(resource){

    // Create string for existing Tags
    var existing_tags = ""
    _.each(resource.tags, function(tag){
      if ( existing_tags == "" ) { existing_tags += tag.tagKey + "=" + tag.tagValue }
      else { existing_tags += ", " + tag.tagKey + "=" + tag.tagValue }
    })

    var tag_support=ds_parsed_tag_support[resource["type"].toLowerCase()];

    if((resource["isMissingTagKey"] || resource["isMissingTagValue"])&&(tag_support!=='FALSE')){
      result.push({
        subscriptionId: resource["subscriptionId"],
        subscriptionName : resource["subscriptionName"],
        id: resource["id"],
        region: resource["region"],
        name: resource["name"],
        resource_group: resource["resourceGroup"],
        namespace: resource["namespace"],
        resource_type: resource["type"],
        all_missed_tag_keys: resource["missingTagKeys"]
        all_missed_tag_value: resource["missingTagValues"]
        all_tags: existing_tags,
        tag_support: tag_support
        })
      }
    })

  //Sort result data
  result = _.sortBy(result, 'subscriptionName')
  result = _.sortBy(result, 'resource_type')
  result = _.sortBy(result, 'name')
  EOS
end

###############################################################################
# Policy
###############################################################################

policy "policy_azure_resource" do
  validate $ds_filtered_resources do
    summary_template "{{ len data }} Azure Resources out of compliance."
    escalate $esc_email
    escalate $esc_tag_resources
    check eq(size(data),0)
    export do
      resource_level true
      field "subscriptionName" do
        label "Subscription Name"
      end
      field "resource_type" do
        label "Resource Type"
      end
      field "tag_support" do
        label "Tag Support"
      end
      field "name" do
        label "Resource Name"
      end
      field "resource_group" do
        label "Resource Group"
      end
      field "region" do
        label "Azure Region"
      end
      field "id" do
        label "Resource ID"
      end
      field "all_tags" do
        label "Existing Tags"
      end
      field "all_missed_tag_keys" do
        label "Missing Tags"
      end
      field "all_missed_tag_values" do
        label "Tag Keys with Missing Tag Values"
      end
      field "subscriptionId" do
        label "Subscription ID"
      end
      field "namespace" do
        label "Namespace"
      end
    end
  end
end

###############################################################################
# Escalations
###############################################################################

escalation "esc_email" do
  automatic true
  label "Send Email"
  description "Send incident email"
  email $param_email
end

#ADD TAGS TO UNTAGGED RESOURCES
escalation "esc_tag_resources" do
  automatic false
  label "Add Tags"
  description "Update tags of the selected resource"
  parameter "param_tags_to_add" do
    type "list"
    label "Add Tags - Enter the list of tags you wish to add to the selected resource. Tags should follow 'Key=Value' format."
    description "Enter the list of tags you wish to add to the selected resource. Tags should follow 'Key=Value' format."
  end
  run "cwf_add_tags", data, $param_tags_to_add, $param_azure_endpoint
end

###############################################################################
# Cloud Workflow
###############################################################################

define cwf_add_tags($data, $param_tags_to_add, $param_azure_endpoint) return $all_responses, $list_of_tags_to_add_foreach_data do
  $$log = []
  $all_responses = []

  $subscriptionId = first($data)["subscriptionId"]
  $$log << "SubscriptionId: "+$subscriptionId

  $providers_response = http_request(
    auth: $$azure_auth,
    verb: "get",
    host: $param_azure_endpoint,
    https: true,
    href: "/subscriptions/" + $subscriptionId +"/providers",
    query_strings: {
      "api-version": "2018-05-01"
    },
    headers: {
      "cache-control": "no-cache",
      "content-type": "application/json"
    }
  )
  $list_of_tags_to_add_foreach_data = []

  foreach $item in $data do
    #from the above request for providers, grab the body/value
    $providers_array = $providers_response["body"]["value"]
    $$log << "ID: "+$item["id"]
    $namespace = $item["namespace"]
    $$log << "Namespace: "+$namespace
    # Drop the provider's namespace from the resource type for example Microsoft.Compute/virtualMachines to virtualMachines
    $resource_type = join(split($item["resource_type"], "/")[1..], "/")
    $$log << "Resource Type: "+$resource_type
    $namespace_obj = select($providers_array, {"namespace": $namespace})
    if $namespace_obj == []
      $namespace_obj = select($providers_array, {"namespace": downcase($namespace)})
    end
    # Within the resourcetype array, get the resource type and the api version for example virtualMachines -> apiVersions = 2015-06-15
    $resource_type_obj = select($namespace_obj[0]["resourceTypes"], {"resourceType": $resource_type})
    $api_versions = $resource_type_obj[0]["apiVersions"]
    $api_version = first($api_versions)
    $$log << "API Version: "+$api_version

    #keep the old tags
    $old_tags_object = {}
    $old_tags = split( $item["all_tags"], ",")
    foreach $old_tag in $old_tags do
      $tag_key = first(split( $old_tag, "="))
      $tag_value = ""
      if $tag_key != last(split( $old_tag, "="))
        $tag_value = last(split( $old_tag, "="))
      end
      $old_tags_object[$tag_key] = $tag_value
    end

    #Tags that are entered as parameter to be applied
    $filtered_tags_to_add_obj = {}
    foreach $tag in $param_tags_to_add do
      $tag_key_to_add = first(split( $tag, "="))
      $tag_value_to_add = ""
      if $tag_key_to_add != last(split( $tag, "="))
        $tag_value_to_add = last(split( $tag, "="))
      end
      $filtered_tags_to_add_obj[$tag_key_to_add] = $tag_value_to_add
    end

    #Combine existing tags with tags to add
    $list_of_tags_to_add_foreach_data = $filtered_tags_to_add_obj + $old_tags_object

    #Update resource api is used to update tags
    #https://learn.microsoft.com/en-us/rest/api/resources/resources/update
    sub on_error: handle_error($update_resource_response) do
      $update_resource_response = http_request(
      auth: $$azure_auth,
        verb: "patch",
        host: $param_azure_endpoint,
        https: true,
        href: $item["id"],
        query_strings: {
          "api-version": $api_version
        },
        headers: {
          "cache-control": "no-cache",
          "content-type": "application/json"
        },
        body: {"tags": $list_of_tags_to_add_foreach_data}
      )
    end
    $all_responses << $update_resource_response
  end
end

define handle_error($response) do
  $status_code = $response["code"]
  if $status_code == 404
    $_error_behavior = "skip"
  else
    $_error_behavior = "raise"
  end
end
