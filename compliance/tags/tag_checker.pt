# Required prolog
name 'Untagged Resources'
rs_pt_ver 20180301
type "policy"
short_description "![Tag](https://s3.amazonaws.com/rs-pft/cat-logos/tag.png)\n
Check for a tag and report which instances and volumes are missing it."
long_description "Version: 1.0"
category "Compliance"
severity "medium"

permission "permissions" do
  label "permissions"
  actions   "rs_cm.index","rs_cm.show"
  resources "rs_cm.instances","rs_cm.volumes"
end

##################
# User inputs    #
##################
parameter "param_tag_keys" do
  category "User Inputs"
  label "Tags' Namespace:Keys List"
  type "string"
  description "Comma-separated list of Tags' Namespace:Keys to audit. For example: \"ec2:project_code\" or \"bu:id\"."
  # allow namespace:key or nothing
  allowed_pattern /^([a-zA-Z0-9-_]+:[a-zA-Z0-9-_]+,*|)+$/
end

# parameter "param_advanced_tag_key" do
#   category "User Inputs"
#   label "Tags' Namespace:Keys Advanced List."
#   type "string"
#   description "A JSON string or publc HTTP URL to json file."
#   #allow http, {*} or nothing.
#   allowed_pattern /^(http|\{.*\}|)/
# end

parameter "param_email" do
  category "Contact"
  label "Email addresses (separate with commas)"
  type "string"
  # allow list of comma seperated email addresses or nothing
  allowed_pattern /^([a-zA-Z0-9-_.]+[@]+[a-zA-Z0-9-_.]+[.]+[a-zA-Z0-9-_]+,*|)+$/
end

# Retrieve all clouds
resources "clouds", type: "rs_cm.clouds" do
  filter do
    cloud_type ne: ["soft_layer", "cloud_stack","azure","rackspace_next_gen",
      "vscale","blue_skies","open_stack_v2","uca","open_stack_v3"]
  end
end

# Retrieve all operational instances across all clouds
resources "instances_operational", type: "rs_cm.instances" do
  iterate @clouds
  cloud_href href(iter_item)
  filter do
    state "operational"
  end
end
# Retrieve all provisioned instances across all clouds
 resources "instances_provisioned", type: "rs_cm.instances" do
   iterate @clouds
   cloud_href href(iter_item)
   filter do
     state "provisioned"
   end
 end

# Retrieve all running instances across all clouds
 resources "instances_running", type: "rs_cm.instances" do
   iterate @clouds
   cloud_href href(iter_item)
   filter do
     state "running"
   end
 end

# Retrieve all volumes across all clouds
resources "volumes", type: "rs_cm.volumes" do
   iterate @clouds
   cloud_href href(iter_item)
end

datasource "clouds" do
  iterate @clouds
  field "href",         href(iter_item)
  field "type",         val(iter_item,'cloud_type')
  field "name",         val(iter_item,'name')
end

datasource "instances_operational" do
   iterate @instances_operational
   field "href",        href(iter_item)
   field "id",          val(iter_item,'resource_uid')
   field "name",        val(iter_item,'name')
   field "state",       val(iter_item,'state')
   field "type",        "instances"
end
datasource "instances_running" do
  iterate @instances_running
  field "href",        href(iter_item)
  field "id",          val(iter_item,'resource_uid')
  field "name",        val(iter_item,'name')
  field "state",       val(iter_item,'state')
  field "type",        "instances"
end
datasource "instances_provisioned" do
  iterate @instances_provisioned
  field "href",        href(iter_item)
  field "id",          val(iter_item,'resource_uid')
  field "name",        val(iter_item,'name')
  field "state",       val(iter_item,'state')
  field "type",        "instances"
end

datasource "volumes" do
   iterate @volumes
   field "href",        href(iter_item)
   field "id",          val(iter_item,'resource_uid')
   field "name",        val(iter_item,'name')
   field "state",       val(iter_item,'status')
   field "type",        "volumes"
end


datasource "resources" do
  run_script $merge_resources, $instances_operational,$instances_running,$instances_provisioned,$volumes
end

script "merge_resources", type: "javascript" do
  parameters "instances_operational","instances_running","instances_provisioned", "volumes"
  result "resources"
  code <<-EOS
    var resources = []
    for (i = 0; i < instances_operational.length; i++) {
      resources.push(instances_operational[i])
    }
    for (i = 0; i < instances_running.length; i++) {
      resources.push(instances_running[i])
    }
    for (i = 0; i < instances_provisioned.length; i++) {
      resources.push(instances_provisioned[i])
    }
    for (i = 0; i < volumes.length; i++) {
      resources.push(volumes[i])
    }
  EOS
end

auth "rs", type: "rightscale"

# get a tagset for all resources
datasource "resource_tags" do
  request do
    auth $rs
    verb "POST"
    host rs_cm_host
    path "/api/tags/by_resource"
    header "X-Api-Version", "1.5"
    body_field "resource_hrefs", vals($resources,"href")
  end
end

datasource "filtered_resources" do
  run_script $filter_resources, $resources, $resource_tags, $clouds, $param_tag_keys
end


script "filter_resources", type: "javascript" do
  parameters "resources","resource_tags","clouds" ,"param_tag_keys"
  result "filtered_resources"
  code <<-EOS
// This is the list of filtered volumes.
var filtered_resources = [];
var tag_keys_array = param_tag_keys.split(',')

// create a map of clouds with href key to get type and name
var cloud_map = {}
for (var i = 0; i < clouds.length; i++) {
    var cloud = clouds[i]
    cloud_map[cloud['href']]={'type': cloud['type'],'name': cloud['name']}
}

// This is the map of volume href to its tags.
var tags = {};
for (var i = 0; i < resource_tags.length; i++) {
  rt = resource_tags[i]
  for (var j = 0; j < rt['links'].length; j++) {
    link = rt['links'][j]
    if (link['rel'] == 'resource') {
      tags[link['href']] = rt['tags']
    }
  }
}

// Go through all the rsources and filter the ones that don't
// comply with the tag rules.
for (var i = 0; i < resources.length; i++) {
  var res = resources[i]
  var res_tags = []
  // Tags is an array of hashes each with just 'name'. Let's convert
  // them to an array of strings.
  for (var j = 0; j < tags[res['href']].length; j++) {
    res_tags.push(tags[res['href']][j]['name'].split("=")[0])
  }

  // Determines whether this resource is properly tagged
  var bad = false;
  var missing_tags = []
  if ( _.intersection(tag_keys_array, res_tags).length != tag_keys_array.length ) {
    bad = true;
    //find the tags missing from the resource
    missing_tags=_.difference(tag_keys_array, res_tags)
  }

  // create cloud_href from resource href
  var split = res['href'].split('/')
  var index = res['href'].indexOf('/'+split[4])
  var cloud_href = res['href'].substring(0,index)

  // update resource array with resources that are missing tags
  if ( bad ) {
    filtered_resources.push(
    { id: res['id'],
      name: res['name'],
      state: res['state'],
      href: res['href'],
      type: res['type'],
      cloud_name: cloud_map[cloud_href]['name'],
      cloud_type: cloud_map[cloud_href]['type'],
      missing_tags: missing_tags,
    }
    )
  }
};
  EOS
end

escalation "escalate_resources" do
  email $param_email
end


resolution "resolve_resources" do
  email $param_email
end

policy "untagged_resources_policy" do
  validate $filtered_resources do
    summary_template "Untagged Resources Summary"
    detail_template <<-EOS
    There are {{ len data }} resource(s) missing tags: {{ parameters.param_tag_keys }} \n
    | Cloud Name | Cloud Type | Name | ID | Type | State | Href | Missing Tags |
    | ---------- | ---------- | ---- | -- | ---- | ----- | ---- | ------------ |
    {{ range data -}}
    | {{ .cloud_name }} | {{ .cloud_type }} | {{ .name }} | {{ .id }} | {{ .type }} | {{ .state }} | {{ .href }} | {{ range $i, $e := .missing_tags }}{{ if $i }}, {{ end }}{{ $e }}{{ end }} |
    {{ end -}}
    EOS
    escalate $escalate_resources
    check eq(size(data), 0)
    resolve $resolve_resources
  end
end
